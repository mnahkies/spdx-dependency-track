/** AUTOGENERATED - DO NOT EDIT **/
/* tslint:disable */

import {
  AbstractFetchClient,
  AbstractFetchClientConfig,
  Res,
  TypedFetchResponse,
} from "@nahkies/typescript-fetch-runtime/main"
import {
  t_actionsAddCustomLabelsToSelfHostedRunnerForOrgJson200Response,
  t_actionsAddCustomLabelsToSelfHostedRunnerForOrgJsonRequestBody,
  t_actionsAddCustomLabelsToSelfHostedRunnerForRepoJson200Response,
  t_actionsAddCustomLabelsToSelfHostedRunnerForRepoJsonRequestBody,
  t_actionsCreateEnvironmentVariableJsonRequestBody,
  t_actionsCreateOrUpdateEnvironmentSecretJsonRequestBody,
  t_actionsCreateOrUpdateOrgSecretJsonRequestBody,
  t_actionsCreateOrUpdateRepoSecretJsonRequestBody,
  t_actionsCreateOrgVariableJsonRequestBody,
  t_actionsCreateRepoVariableJsonRequestBody,
  t_actionsCreateWorkflowDispatchJsonRequestBody,
  t_actionsGenerateRunnerJitconfigForOrgJson201Response,
  t_actionsGenerateRunnerJitconfigForOrgJsonRequestBody,
  t_actionsGenerateRunnerJitconfigForRepoJson201Response,
  t_actionsGenerateRunnerJitconfigForRepoJsonRequestBody,
  t_actionsGetActionsCacheUsageByRepoForOrgJson200Response,
  t_actionsListArtifactsForRepoJson200Response,
  t_actionsListEnvironmentSecretsJson200Response,
  t_actionsListEnvironmentVariablesJson200Response,
  t_actionsListJobsForWorkflowRunAttemptJson200Response,
  t_actionsListJobsForWorkflowRunJson200Response,
  t_actionsListLabelsForSelfHostedRunnerForOrgJson200Response,
  t_actionsListLabelsForSelfHostedRunnerForRepoJson200Response,
  t_actionsListOrgSecretsJson200Response,
  t_actionsListOrgVariablesJson200Response,
  t_actionsListRepoOrganizationSecretsJson200Response,
  t_actionsListRepoOrganizationVariablesJson200Response,
  t_actionsListRepoSecretsJson200Response,
  t_actionsListRepoVariablesJson200Response,
  t_actionsListRepoWorkflowsJson200Response,
  t_actionsListSelectedReposForOrgSecretJson200Response,
  t_actionsListSelectedReposForOrgVariableJson200Response,
  t_actionsListSelectedRepositoriesEnabledGithubActionsOrganizationJson200Response,
  t_actionsListSelfHostedRunnersForOrgJson200Response,
  t_actionsListSelfHostedRunnersForRepoJson200Response,
  t_actionsListWorkflowRunArtifactsJson200Response,
  t_actionsListWorkflowRunsForRepoJson200Response,
  t_actionsListWorkflowRunsJson200Response,
  t_actionsReRunJobForWorkflowRunJsonRequestBody,
  t_actionsReRunWorkflowFailedJobsJsonRequestBody,
  t_actionsReRunWorkflowJsonRequestBody,
  t_actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgJson200Response,
  t_actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoJson200Response,
  t_actionsRemoveCustomLabelFromSelfHostedRunnerForOrgJson200Response,
  t_actionsRemoveCustomLabelFromSelfHostedRunnerForRepoJson200Response,
  t_actionsReviewCustomGatesForRunJsonRequestBody,
  t_actionsReviewPendingDeploymentsForRunJsonRequestBody,
  t_actionsSetCustomLabelsForSelfHostedRunnerForOrgJson200Response,
  t_actionsSetCustomLabelsForSelfHostedRunnerForOrgJsonRequestBody,
  t_actionsSetCustomLabelsForSelfHostedRunnerForRepoJson200Response,
  t_actionsSetCustomLabelsForSelfHostedRunnerForRepoJsonRequestBody,
  t_actionsSetCustomOidcSubClaimForRepoJsonRequestBody,
  t_actionsSetGithubActionsPermissionsOrganizationJsonRequestBody,
  t_actionsSetGithubActionsPermissionsRepositoryJsonRequestBody,
  t_actionsSetSelectedReposForOrgSecretJsonRequestBody,
  t_actionsSetSelectedReposForOrgVariableJsonRequestBody,
  t_actionsSetSelectedRepositoriesEnabledGithubActionsOrganizationJsonRequestBody,
  t_actionsUpdateEnvironmentVariableJsonRequestBody,
  t_actionsUpdateOrgVariableJsonRequestBody,
  t_actionsUpdateRepoVariableJsonRequestBody,
  t_actions_billing_usage,
  t_actions_cache_list,
  t_actions_cache_usage_by_repository,
  t_actions_cache_usage_org_enterprise,
  t_actions_get_default_workflow_permissions,
  t_actions_organization_permissions,
  t_actions_public_key,
  t_actions_repository_permissions,
  t_actions_secret,
  t_actions_set_default_workflow_permissions,
  t_actions_variable,
  t_actions_workflow_access_to_repository,
  t_activity,
  t_activityListPublicEventsJson503Response,
  t_activityListReposStarredByUserJson200Response,
  t_activityListStargazersForRepoJson200Response,
  t_activityMarkNotificationsAsReadJson202Response,
  t_activityMarkNotificationsAsReadJsonRequestBody,
  t_activityMarkRepoNotificationsAsReadJson202Response,
  t_activityMarkRepoNotificationsAsReadJsonRequestBody,
  t_activitySetRepoSubscriptionJsonRequestBody,
  t_activitySetThreadSubscriptionJsonRequestBody,
  t_alert_number,
  t_api_overview,
  t_appsCheckTokenJsonRequestBody,
  t_appsCreateFromManifestJson201Response,
  t_appsCreateInstallationAccessTokenJsonRequestBody,
  t_appsDeleteAuthorizationJsonRequestBody,
  t_appsDeleteTokenJsonRequestBody,
  t_appsListInstallationReposForAuthenticatedUserJson200Response,
  t_appsListInstallationsForAuthenticatedUserJson200Response,
  t_appsListReposAccessibleToInstallationJson200Response,
  t_appsRedeliverWebhookDeliveryJson202Response,
  t_appsResetTokenJsonRequestBody,
  t_appsScopeTokenJsonRequestBody,
  t_appsUpdateWebhookConfigForAppJsonRequestBody,
  t_artifact,
  t_authentication_token,
  t_authorization,
  t_autolink,
  t_base_gist,
  t_basic_error,
  t_blob,
  t_branch_protection,
  t_branch_restriction_policy,
  t_branch_short,
  t_branch_with_protection,
  t_check_annotation,
  t_check_automated_security_fixes,
  t_check_run,
  t_check_suite,
  t_check_suite_preference,
  t_checksCreateJsonRequestBody,
  t_checksCreateSuiteJsonRequestBody,
  t_checksListForRefJson200Response,
  t_checksListForSuiteJson200Response,
  t_checksListSuitesForRefJson200Response,
  t_checksSetSuitesPreferencesJsonRequestBody,
  t_checksUpdateJsonRequestBody,
  t_classroom,
  t_classroom_accepted_assignment,
  t_classroom_assignment,
  t_classroom_assignment_grade,
  t_clone_traffic,
  t_codeScanningDeleteAnalysisJson503Response,
  t_codeScanningGetAlertJson503Response,
  t_codeScanningGetAnalysisApplicationJsonSarif200Response,
  t_codeScanningGetAnalysisJson503Response,
  t_codeScanningGetCodeqlDatabaseJson503Response,
  t_codeScanningGetDefaultSetupJson503Response,
  t_codeScanningGetSarifJson503Response,
  t_codeScanningListAlertInstancesJson503Response,
  t_codeScanningListAlertsForOrgJson503Response,
  t_codeScanningListAlertsForRepoJson503Response,
  t_codeScanningListCodeqlDatabasesJson503Response,
  t_codeScanningListRecentAnalysesJson503Response,
  t_codeScanningUpdateAlertJson503Response,
  t_codeScanningUpdateAlertJsonRequestBody,
  t_codeScanningUpdateDefaultSetupJson503Response,
  t_codeScanningUploadSarifJson503Response,
  t_codeScanningUploadSarifJsonRequestBody,
  t_code_frequency_stat,
  t_code_of_conduct,
  t_code_scanning_alert,
  t_code_scanning_alert_instance,
  t_code_scanning_alert_items,
  t_code_scanning_alert_severity,
  t_code_scanning_alert_state_query,
  t_code_scanning_analysis,
  t_code_scanning_analysis_deletion,
  t_code_scanning_analysis_sarif_id,
  t_code_scanning_analysis_tool_guid,
  t_code_scanning_analysis_tool_name,
  t_code_scanning_codeql_database,
  t_code_scanning_default_setup,
  t_code_scanning_default_setup_update,
  t_code_scanning_default_setup_update_response,
  t_code_scanning_organization_alert_items,
  t_code_scanning_ref,
  t_code_scanning_sarifs_receipt,
  t_code_scanning_sarifs_status,
  t_codeowners_errors,
  t_codespace,
  t_codespace_export_details,
  t_codespace_with_full_repository,
  t_codespacesCheckPermissionsForDevcontainerJson503Response,
  t_codespacesCodespaceMachinesForAuthenticatedUserJson200Response,
  t_codespacesCreateForAuthenticatedUserJson503Response,
  t_codespacesCreateForAuthenticatedUserJsonRequestBody,
  t_codespacesCreateOrUpdateOrgSecretJsonRequestBody,
  t_codespacesCreateOrUpdateRepoSecretJsonRequestBody,
  t_codespacesCreateOrUpdateSecretForAuthenticatedUserJsonRequestBody,
  t_codespacesCreateWithPrForAuthenticatedUserJson503Response,
  t_codespacesCreateWithPrForAuthenticatedUserJsonRequestBody,
  t_codespacesCreateWithRepoForAuthenticatedUserJson503Response,
  t_codespacesCreateWithRepoForAuthenticatedUserJsonRequestBody,
  t_codespacesDeleteCodespacesAccessUsersJsonRequestBody,
  t_codespacesDeleteForAuthenticatedUserJson202Response,
  t_codespacesDeleteFromOrganizationJson202Response,
  t_codespacesGetCodespacesForUserInOrgJson200Response,
  t_codespacesListDevcontainersInRepositoryForAuthenticatedUserJson200Response,
  t_codespacesListForAuthenticatedUserJson200Response,
  t_codespacesListInOrganizationJson200Response,
  t_codespacesListInRepositoryForAuthenticatedUserJson200Response,
  t_codespacesListOrgSecretsJson200Response,
  t_codespacesListRepoSecretsJson200Response,
  t_codespacesListRepositoriesForSecretForAuthenticatedUserJson200Response,
  t_codespacesListSecretsForAuthenticatedUserJson200Response,
  t_codespacesListSelectedReposForOrgSecretJson200Response,
  t_codespacesPreFlightWithRepoForAuthenticatedUserJson200Response,
  t_codespacesPublishForAuthenticatedUserJsonRequestBody,
  t_codespacesRepoMachinesForAuthenticatedUserJson200Response,
  t_codespacesSetCodespacesAccessJsonRequestBody,
  t_codespacesSetCodespacesAccessUsersJsonRequestBody,
  t_codespacesSetRepositoriesForSecretForAuthenticatedUserJsonRequestBody,
  t_codespacesSetSelectedReposForOrgSecretJsonRequestBody,
  t_codespacesUpdateForAuthenticatedUserJsonRequestBody,
  t_codespaces_org_secret,
  t_codespaces_permissions_check_for_devcontainer,
  t_codespaces_public_key,
  t_codespaces_secret,
  t_codespaces_user_public_key,
  t_collaborator,
  t_combined_billing_usage,
  t_combined_commit_status,
  t_commit,
  t_commit_activity,
  t_commit_comment,
  t_commit_comparison,
  t_community_profile,
  t_content_file,
  t_content_traffic,
  t_contributor,
  t_contributor_activity,
  t_copilotAddCopilotSeatsForTeamsJson201Response,
  t_copilotAddCopilotSeatsForTeamsJsonRequestBody,
  t_copilotAddCopilotSeatsForUsersJson201Response,
  t_copilotAddCopilotSeatsForUsersJsonRequestBody,
  t_copilotCancelCopilotSeatAssignmentForTeamsJson200Response,
  t_copilotCancelCopilotSeatAssignmentForTeamsJsonRequestBody,
  t_copilotCancelCopilotSeatAssignmentForUsersJson200Response,
  t_copilotCancelCopilotSeatAssignmentForUsersJsonRequestBody,
  t_copilotListCopilotSeatsJson200Response,
  t_copilot_organization_details,
  t_copilot_seat_details,
  t_custom_property_value,
  t_dependabotCreateOrUpdateOrgSecretJsonRequestBody,
  t_dependabotCreateOrUpdateRepoSecretJsonRequestBody,
  t_dependabotListOrgSecretsJson200Response,
  t_dependabotListRepoSecretsJson200Response,
  t_dependabotListSelectedReposForOrgSecretJson200Response,
  t_dependabotSetSelectedReposForOrgSecretJsonRequestBody,
  t_dependabotUpdateAlertJsonRequestBody,
  t_dependabot_alert,
  t_dependabot_alert_with_repository,
  t_dependabot_public_key,
  t_dependabot_secret,
  t_dependencyGraphCreateRepositorySnapshotJson201Response,
  t_dependency_graph_diff,
  t_dependency_graph_spdx_sbom,
  t_deploy_key,
  t_deployment,
  t_deployment_branch_policy,
  t_deployment_branch_policy_name_pattern,
  t_deployment_branch_policy_name_pattern_with_type,
  t_deployment_protection_rule,
  t_deployment_status,
  t_diff_entry,
  t_email,
  t_emojisGetJson200Response,
  t_empty_object,
  t_environment,
  t_environment_approvals,
  t_event,
  t_feed,
  t_file_commit,
  t_full_repository,
  t_gist_comment,
  t_gist_commit,
  t_gist_simple,
  t_gistsCheckIsStarredJson404Response,
  t_gistsCreateCommentJsonRequestBody,
  t_gistsCreateJsonRequestBody,
  t_gistsGetCommentJson403Response,
  t_gistsGetJson403Response,
  t_gistsUpdateCommentJsonRequestBody,
  t_gistsUpdateJsonRequestBody,
  t_gitCreateBlobJsonRequestBody,
  t_gitCreateCommitJsonRequestBody,
  t_gitCreateRefJsonRequestBody,
  t_gitCreateTagJsonRequestBody,
  t_gitCreateTreeJsonRequestBody,
  t_gitUpdateRefJsonRequestBody,
  t_git_commit,
  t_git_ref,
  t_git_tag,
  t_git_tree,
  t_gitignore_template,
  t_global_advisory,
  t_gpg_key,
  t_hook,
  t_hook_delivery,
  t_hook_delivery_item,
  t_hovercard,
  t_import,
  t_installation,
  t_installation_token,
  t_integration,
  t_integration_installation_request,
  t_interaction_limit,
  t_interaction_limit_response,
  t_interactionsGetRestrictionsForAuthenticatedUserJson200Response,
  t_interactionsGetRestrictionsForOrgJson200Response,
  t_interactionsGetRestrictionsForRepoJson200Response,
  t_issue,
  t_issue_comment,
  t_issue_event,
  t_issue_event_for_issue,
  t_issuesAddAssigneesJsonRequestBody,
  t_issuesAddLabelsJsonRequestBody,
  t_issuesCreateCommentJsonRequestBody,
  t_issuesCreateJson503Response,
  t_issuesCreateJsonRequestBody,
  t_issuesCreateLabelJsonRequestBody,
  t_issuesCreateMilestoneJsonRequestBody,
  t_issuesLockJsonRequestBody,
  t_issuesRemoveAssigneesJsonRequestBody,
  t_issuesSetLabelsJsonRequestBody,
  t_issuesUpdateCommentJsonRequestBody,
  t_issuesUpdateJson503Response,
  t_issuesUpdateJsonRequestBody,
  t_issuesUpdateLabelJsonRequestBody,
  t_issuesUpdateMilestoneJsonRequestBody,
  t_job,
  t_key,
  t_key_simple,
  t_label,
  t_language,
  t_license,
  t_license_content,
  t_license_simple,
  t_markdownRenderJsonRequestBody,
  t_marketplace_listing_plan,
  t_marketplace_purchase,
  t_merged_upstream,
  t_migration,
  t_migrationsMapCommitAuthorJsonRequestBody,
  t_migrationsSetLfsPreferenceJsonRequestBody,
  t_migrationsStartForAuthenticatedUserJsonRequestBody,
  t_migrationsStartForOrgJsonRequestBody,
  t_migrationsStartImportJsonRequestBody,
  t_migrationsUpdateImportJsonRequestBody,
  t_milestone,
  t_minimal_repository,
  t_oidc_custom_sub,
  t_oidc_custom_sub_repo,
  t_org_custom_property,
  t_org_hook,
  t_org_membership,
  t_org_repo_custom_property_values,
  t_organization_actions_secret,
  t_organization_actions_variable,
  t_organization_dependabot_secret,
  t_organization_fine_grained_permission,
  t_organization_full,
  t_organization_invitation,
  t_organization_programmatic_access_grant,
  t_organization_programmatic_access_grant_request,
  t_organization_role,
  t_organization_secret_scanning_alert,
  t_organization_simple,
  t_orgsConvertMemberToOutsideCollaboratorJson202Response,
  t_orgsConvertMemberToOutsideCollaboratorJsonRequestBody,
  t_orgsCreateCustomOrganizationRoleJsonRequestBody,
  t_orgsCreateInvitationJsonRequestBody,
  t_orgsCreateOrUpdateCustomPropertiesJsonRequestBody,
  t_orgsCreateOrUpdateCustomPropertiesValuesForReposJsonRequestBody,
  t_orgsCreateOrUpdateCustomPropertyJsonRequestBody,
  t_orgsCreateWebhookJsonRequestBody,
  t_orgsDeleteJson202Response,
  t_orgsEnableOrDisableSecurityProductOnAllOrgReposJsonRequestBody,
  t_orgsListAppInstallationsJson200Response,
  t_orgsListOrgRolesJson200Response,
  t_orgsPatchCustomOrganizationRoleJsonRequestBody,
  t_orgsRedeliverWebhookDeliveryJson202Response,
  t_orgsRemoveOutsideCollaboratorJson422Response,
  t_orgsReviewPatGrantRequestJsonRequestBody,
  t_orgsReviewPatGrantRequestsInBulkJson202Response,
  t_orgsReviewPatGrantRequestsInBulkJsonRequestBody,
  t_orgsSetMembershipForUserJsonRequestBody,
  t_orgsUpdateJson422Response,
  t_orgsUpdateJsonRequestBody,
  t_orgsUpdateMembershipForAuthenticatedUserJsonRequestBody,
  t_orgsUpdatePatAccessJsonRequestBody,
  t_orgsUpdatePatAccessesJson202Response,
  t_orgsUpdatePatAccessesJsonRequestBody,
  t_orgsUpdateWebhookConfigForOrgJsonRequestBody,
  t_orgsUpdateWebhookJsonRequestBody,
  t_package,
  t_package_version,
  t_packages_billing_usage,
  t_page,
  t_page_build,
  t_page_build_status,
  t_page_deployment,
  t_pages_deployment_status,
  t_pages_health_check,
  t_participation_stats,
  t_pending_deployment,
  t_porter_author,
  t_porter_large_file,
  t_private_user,
  t_private_vulnerability_report_create,
  t_project,
  t_project_card,
  t_project_collaborator_permission,
  t_project_column,
  t_projectsAddCollaboratorJsonRequestBody,
  t_projectsCreateCardJson422Response,
  t_projectsCreateCardJson503Response,
  t_projectsCreateCardJsonRequestBody,
  t_projectsCreateColumnJsonRequestBody,
  t_projectsCreateForAuthenticatedUserJsonRequestBody,
  t_projectsCreateForOrgJsonRequestBody,
  t_projectsCreateForRepoJsonRequestBody,
  t_projectsDeleteCardJson403Response,
  t_projectsDeleteJson403Response,
  t_projectsMoveCardJson201Response,
  t_projectsMoveCardJson403Response,
  t_projectsMoveCardJson503Response,
  t_projectsMoveCardJsonRequestBody,
  t_projectsMoveColumnJson201Response,
  t_projectsMoveColumnJsonRequestBody,
  t_projectsUpdateCardJsonRequestBody,
  t_projectsUpdateColumnJsonRequestBody,
  t_projectsUpdateJson403Response,
  t_projectsUpdateJsonRequestBody,
  t_protected_branch,
  t_protected_branch_admin_enforced,
  t_protected_branch_pull_request_review,
  t_pull_request,
  t_pull_request_merge_result,
  t_pull_request_review,
  t_pull_request_review_comment,
  t_pull_request_review_request,
  t_pull_request_simple,
  t_pullsCreateJsonRequestBody,
  t_pullsCreateReplyForReviewCommentJsonRequestBody,
  t_pullsCreateReviewCommentJsonRequestBody,
  t_pullsCreateReviewJsonRequestBody,
  t_pullsDismissReviewJsonRequestBody,
  t_pullsGetJson503Response,
  t_pullsListFilesJson503Response,
  t_pullsMergeJson405Response,
  t_pullsMergeJson409Response,
  t_pullsMergeJsonRequestBody,
  t_pullsRemoveRequestedReviewersJsonRequestBody,
  t_pullsRequestReviewersJsonRequestBody,
  t_pullsSubmitReviewJsonRequestBody,
  t_pullsUpdateBranchJson202Response,
  t_pullsUpdateBranchJsonRequestBody,
  t_pullsUpdateJsonRequestBody,
  t_pullsUpdateReviewCommentJsonRequestBody,
  t_pullsUpdateReviewJsonRequestBody,
  t_rate_limit_overview,
  t_reaction,
  t_reactionsCreateForCommitCommentJsonRequestBody,
  t_reactionsCreateForIssueCommentJsonRequestBody,
  t_reactionsCreateForIssueJsonRequestBody,
  t_reactionsCreateForPullRequestReviewCommentJsonRequestBody,
  t_reactionsCreateForReleaseJsonRequestBody,
  t_reactionsCreateForTeamDiscussionCommentInOrgJsonRequestBody,
  t_reactionsCreateForTeamDiscussionCommentLegacyJsonRequestBody,
  t_reactionsCreateForTeamDiscussionInOrgJsonRequestBody,
  t_reactionsCreateForTeamDiscussionLegacyJsonRequestBody,
  t_referrer_traffic,
  t_release,
  t_release_asset,
  t_release_notes_content,
  t_repo_codespaces_secret,
  t_reposAddAppAccessRestrictionsJsonRequestBody,
  t_reposAddCollaboratorJsonRequestBody,
  t_reposAddStatusCheckContextsJsonRequestBody,
  t_reposAddTeamAccessRestrictionsJsonRequestBody,
  t_reposAddUserAccessRestrictionsJsonRequestBody,
  t_reposCheckPrivateVulnerabilityReportingJson200Response,
  t_reposCompareCommitsJson503Response,
  t_reposCreateAutolinkJsonRequestBody,
  t_reposCreateCommitCommentJsonRequestBody,
  t_reposCreateCommitStatusJsonRequestBody,
  t_reposCreateDeployKeyJsonRequestBody,
  t_reposCreateDeploymentJson202Response,
  t_reposCreateDeploymentJsonRequestBody,
  t_reposCreateDeploymentProtectionRuleJsonRequestBody,
  t_reposCreateDeploymentStatusJsonRequestBody,
  t_reposCreateDispatchEventJsonRequestBody,
  t_reposCreateForAuthenticatedUserJsonRequestBody,
  t_reposCreateForkJsonRequestBody,
  t_reposCreateInOrgJsonRequestBody,
  t_reposCreateOrUpdateCustomPropertiesValuesJsonRequestBody,
  t_reposCreateOrUpdateEnvironmentJsonRequestBody,
  t_reposCreateOrUpdateFileContentsJsonRequestBody,
  t_reposCreateOrgRulesetJsonRequestBody,
  t_reposCreatePagesDeploymentJsonRequestBody,
  t_reposCreatePagesSiteJsonRequestBody,
  t_reposCreateReleaseJsonRequestBody,
  t_reposCreateRepoRulesetJsonRequestBody,
  t_reposCreateTagProtectionJsonRequestBody,
  t_reposCreateUsingTemplateJsonRequestBody,
  t_reposCreateWebhookJsonRequestBody,
  t_reposDeleteFileJson503Response,
  t_reposDeleteFileJsonRequestBody,
  t_reposDeleteJson403Response,
  t_reposGenerateReleaseNotesJsonRequestBody,
  t_reposGetAllDeploymentProtectionRulesJson200Response,
  t_reposGetAllEnvironmentsJson200Response,
  t_reposGetCodeFrequencyStatsJson202Response,
  t_reposGetCommitActivityStatsJson202Response,
  t_reposGetCommitJson503Response,
  t_reposGetContentJson200Response,
  t_reposGetContributorsStatsJson202Response,
  t_reposListCustomDeploymentRuleIntegrationsJson200Response,
  t_reposListDeploymentBranchPoliciesJson200Response,
  t_reposMergeJsonRequestBody,
  t_reposMergeUpstreamJsonRequestBody,
  t_reposRedeliverWebhookDeliveryJson202Response,
  t_reposRemoveAppAccessRestrictionsJsonRequestBody,
  t_reposRemoveStatusCheckContextsJsonRequestBody,
  t_reposRemoveTeamAccessRestrictionsJsonRequestBody,
  t_reposRemoveUserAccessRestrictionsJsonRequestBody,
  t_reposRenameBranchJsonRequestBody,
  t_reposReplaceAllTopicsJsonRequestBody,
  t_reposSetAppAccessRestrictionsJsonRequestBody,
  t_reposSetStatusCheckContextsJsonRequestBody,
  t_reposSetTeamAccessRestrictionsJsonRequestBody,
  t_reposSetUserAccessRestrictionsJsonRequestBody,
  t_reposTransferJsonRequestBody,
  t_reposUpdateBranchProtectionJsonRequestBody,
  t_reposUpdateCommitCommentJsonRequestBody,
  t_reposUpdateInformationAboutPagesSiteJsonRequestBody,
  t_reposUpdateInvitationJsonRequestBody,
  t_reposUpdateJsonRequestBody,
  t_reposUpdateOrgRulesetJsonRequestBody,
  t_reposUpdatePullRequestReviewProtectionJsonRequestBody,
  t_reposUpdateReleaseAssetJsonRequestBody,
  t_reposUpdateReleaseJsonRequestBody,
  t_reposUpdateRepoRulesetJsonRequestBody,
  t_reposUpdateStatusCheckProtectionJsonRequestBody,
  t_reposUpdateWebhookConfigForRepoJsonRequestBody,
  t_reposUpdateWebhookJsonRequestBody,
  t_repository,
  t_repository_advisory,
  t_repository_advisory_create,
  t_repository_advisory_update,
  t_repository_collaborator_permission,
  t_repository_invitation,
  t_repository_rule_detailed,
  t_repository_ruleset,
  t_repository_subscription,
  t_review_comment,
  t_root,
  t_rule_suite,
  t_rule_suites,
  t_runner,
  t_runner_application,
  t_scim_error,
  t_searchCodeJson200Response,
  t_searchCodeJson503Response,
  t_searchCommitsJson200Response,
  t_searchIssuesAndPullRequestsJson200Response,
  t_searchIssuesAndPullRequestsJson503Response,
  t_searchLabelsJson200Response,
  t_searchReposJson200Response,
  t_searchReposJson503Response,
  t_searchTopicsJson200Response,
  t_searchUsersJson200Response,
  t_searchUsersJson503Response,
  t_secretScanningGetAlertJson503Response,
  t_secretScanningListAlertsForEnterpriseJson503Response,
  t_secretScanningListAlertsForOrgJson503Response,
  t_secretScanningListAlertsForRepoJson503Response,
  t_secretScanningListLocationsForAlertJson503Response,
  t_secretScanningUpdateAlertJson503Response,
  t_secretScanningUpdateAlertJsonRequestBody,
  t_secret_scanning_alert,
  t_secret_scanning_location,
  t_securityAdvisoriesCreateRepositoryAdvisoryCveRequestJson202Response,
  t_security_advisory_ecosystems,
  t_selected_actions,
  t_short_blob,
  t_short_branch,
  t_simple_classroom,
  t_simple_classroom_assignment,
  t_simple_user,
  t_snapshot,
  t_social_account,
  t_ssh_signing_key,
  t_starred_repository,
  t_status,
  t_status_check_policy,
  t_tag,
  t_tag_protection,
  t_team,
  t_team_discussion,
  t_team_discussion_comment,
  t_team_full,
  t_team_membership,
  t_team_project,
  t_team_repository,
  t_team_simple,
  t_teamsAddOrUpdateMembershipForUserInOrgJsonRequestBody,
  t_teamsAddOrUpdateMembershipForUserLegacyJsonRequestBody,
  t_teamsAddOrUpdateProjectPermissionsInOrgJson403Response,
  t_teamsAddOrUpdateProjectPermissionsInOrgJsonRequestBody,
  t_teamsAddOrUpdateProjectPermissionsLegacyJson403Response,
  t_teamsAddOrUpdateProjectPermissionsLegacyJsonRequestBody,
  t_teamsAddOrUpdateRepoPermissionsInOrgJsonRequestBody,
  t_teamsAddOrUpdateRepoPermissionsLegacyJsonRequestBody,
  t_teamsCreateDiscussionCommentInOrgJsonRequestBody,
  t_teamsCreateDiscussionCommentLegacyJsonRequestBody,
  t_teamsCreateDiscussionInOrgJsonRequestBody,
  t_teamsCreateDiscussionLegacyJsonRequestBody,
  t_teamsCreateJsonRequestBody,
  t_teamsUpdateDiscussionCommentInOrgJsonRequestBody,
  t_teamsUpdateDiscussionCommentLegacyJsonRequestBody,
  t_teamsUpdateDiscussionInOrgJsonRequestBody,
  t_teamsUpdateDiscussionLegacyJsonRequestBody,
  t_teamsUpdateInOrgJsonRequestBody,
  t_teamsUpdateLegacyJsonRequestBody,
  t_thread,
  t_thread_subscription,
  t_timeline_issue_events,
  t_topic,
  t_user_marketplace_purchase,
  t_usersAddEmailForAuthenticatedUserJsonRequestBody,
  t_usersAddSocialAccountForAuthenticatedUserJsonRequestBody,
  t_usersCreateGpgKeyForAuthenticatedUserJsonRequestBody,
  t_usersCreatePublicSshKeyForAuthenticatedUserJsonRequestBody,
  t_usersCreateSshSigningKeyForAuthenticatedUserJsonRequestBody,
  t_usersDeleteEmailForAuthenticatedUserJsonRequestBody,
  t_usersDeleteSocialAccountForAuthenticatedUserJsonRequestBody,
  t_usersGetAuthenticatedJson200Response,
  t_usersGetByUsernameJson200Response,
  t_usersSetPrimaryEmailVisibilityForAuthenticatedUserJsonRequestBody,
  t_usersUpdateAuthenticatedJsonRequestBody,
  t_validation_error,
  t_validation_error_simple,
  t_view_traffic,
  t_webhook_config,
  t_workflow,
  t_workflow_run,
  t_workflow_run_usage,
  t_workflow_usage,
} from "./models"

export interface ApiClientConfig extends AbstractFetchClientConfig {}

export class ApiClient extends AbstractFetchClient {
  constructor(config: ApiClientConfig) {
    super(config)
  }

  async metaRoot(
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_root>>> {
    const url = this.basePath + `/`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async securityAdvisoriesListGlobalAdvisories(
    p: {
      ghsaId?: string
      type?: "reviewed" | "malware" | "unreviewed"
      cveId?: string
      ecosystem?: t_security_advisory_ecosystems
      severity?: "unknown" | "low" | "medium" | "high" | "critical"
      cwes?: string | string[]
      isWithdrawn?: boolean
      affects?: string | string[]
      published?: string
      updated?: string
      modified?: string
      before?: string
      after?: string
      direction?: "asc" | "desc"
      perPage?: number
      sort?: "updated" | "published"
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_global_advisory[]>
      | Res<422, t_validation_error_simple>
      | Res<429, t_basic_error>
    >
  > {
    const url = this.basePath + `/advisories`
    const query = this._query({
      ghsa_id: p["ghsaId"],
      type: p["type"],
      cve_id: p["cveId"],
      ecosystem: p["ecosystem"],
      severity: p["severity"],
      cwes: p["cwes"],
      is_withdrawn: p["isWithdrawn"],
      affects: p["affects"],
      published: p["published"],
      updated: p["updated"],
      modified: p["modified"],
      before: p["before"],
      after: p["after"],
      direction: p["direction"],
      per_page: p["perPage"],
      sort: p["sort"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async securityAdvisoriesGetGlobalAdvisory(
    p: {
      ghsaId: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_global_advisory> | Res<404, t_basic_error>>
  > {
    const url = this.basePath + `/advisories/${p["ghsaId"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async appsGetAuthenticated(
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_integration>>> {
    const url = this.basePath + `/app`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async appsCreateFromManifest(
    p: {
      code: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_appsCreateFromManifestJson201Response>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error_simple>
    >
  > {
    const url = this.basePath + `/app-manifests/${p["code"]}/conversions`

    return this._fetch(url, {method: "POST", ...(opts ?? {})}, timeout)
  }

  async appsGetWebhookConfigForApp(
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_webhook_config>>> {
    const url = this.basePath + `/app/hook/config`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async appsUpdateWebhookConfigForApp(
    p: {
      requestBody: t_appsUpdateWebhookConfigForAppJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_webhook_config>>> {
    const url = this.basePath + `/app/hook/config`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PATCH", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async appsListWebhookDeliveries(
    p: {
      perPage?: number
      cursor?: string
      redelivery?: boolean
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_hook_delivery_item[]>
      | Res<400, t_scim_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/app/hook/deliveries`
    const query = this._query({
      per_page: p["perPage"],
      cursor: p["cursor"],
      redelivery: p["redelivery"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async appsGetWebhookDelivery(
    p: {
      deliveryId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_hook_delivery>
      | Res<400, t_scim_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/app/hook/deliveries/${p["deliveryId"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async appsRedeliverWebhookDelivery(
    p: {
      deliveryId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<202, t_appsRedeliverWebhookDeliveryJson202Response>
      | Res<400, t_scim_error>
      | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath + `/app/hook/deliveries/${p["deliveryId"]}/attempts`

    return this._fetch(url, {method: "POST", ...(opts ?? {})}, timeout)
  }

  async appsListInstallationRequestsForAuthenticatedApp(
    p: {
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_integration_installation_request[]>
      | Res<304, void>
      | Res<401, t_basic_error>
    >
  > {
    const url = this.basePath + `/app/installation-requests`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async appsListInstallations(
    p: {
      perPage?: number
      page?: number
      since?: string
      outdated?: string
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_installation[]>>> {
    const url = this.basePath + `/app/installations`
    const query = this._query({
      per_page: p["perPage"],
      page: p["page"],
      since: p["since"],
      outdated: p["outdated"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async appsGetInstallation(
    p: {
      installationId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_installation> | Res<404, t_basic_error>>
  > {
    const url = this.basePath + `/app/installations/${p["installationId"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async appsDeleteInstallation(
    p: {
      installationId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void> | Res<404, t_basic_error>>> {
    const url = this.basePath + `/app/installations/${p["installationId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async appsCreateInstallationAccessToken(
    p: {
      installationId: number
      requestBody?: t_appsCreateInstallationAccessTokenJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_installation_token>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath + `/app/installations/${p["installationId"]}/access_tokens`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async appsSuspendInstallation(
    p: {
      installationId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void> | Res<404, t_basic_error>>> {
    const url =
      this.basePath + `/app/installations/${p["installationId"]}/suspended`

    return this._fetch(url, {method: "PUT", ...(opts ?? {})}, timeout)
  }

  async appsUnsuspendInstallation(
    p: {
      installationId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void> | Res<404, t_basic_error>>> {
    const url =
      this.basePath + `/app/installations/${p["installationId"]}/suspended`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async appsDeleteAuthorization(
    p: {
      clientId: string
      requestBody: t_appsDeleteAuthorizationJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<204, void> | Res<422, t_validation_error>>
  > {
    const url = this.basePath + `/applications/${p["clientId"]}/grant`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "DELETE", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async appsCheckToken(
    p: {
      clientId: string
      requestBody: t_appsCheckTokenJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_authorization>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/applications/${p["clientId"]}/token`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async appsResetToken(
    p: {
      clientId: string
      requestBody: t_appsResetTokenJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_authorization> | Res<422, t_validation_error>>
  > {
    const url = this.basePath + `/applications/${p["clientId"]}/token`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PATCH", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async appsDeleteToken(
    p: {
      clientId: string
      requestBody: t_appsDeleteTokenJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<204, void> | Res<422, t_validation_error>>
  > {
    const url = this.basePath + `/applications/${p["clientId"]}/token`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "DELETE", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async appsScopeToken(
    p: {
      clientId: string
      requestBody: t_appsScopeTokenJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_authorization>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/applications/${p["clientId"]}/token/scoped`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async appsGetBySlug(
    p: {
      appSlug: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_integration>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/apps/${p["appSlug"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async classroomGetAnAssignment(
    p: {
      assignmentId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_classroom_assignment> | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/assignments/${p["assignmentId"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async classroomListAcceptedAssigmentsForAnAssignment(
    p: {
      assignmentId: number
      page?: number
      perPage?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_classroom_accepted_assignment[]>>> {
    const url =
      this.basePath + `/assignments/${p["assignmentId"]}/accepted_assignments`
    const query = this._query({page: p["page"], per_page: p["perPage"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async classroomGetAssignmentGrades(
    p: {
      assignmentId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_classroom_assignment_grade[]> | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/assignments/${p["assignmentId"]}/grades`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async classroomListClassrooms(
    p: {
      page?: number
      perPage?: number
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_simple_classroom[]>>> {
    const url = this.basePath + `/classrooms`
    const query = this._query({page: p["page"], per_page: p["perPage"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async classroomGetAClassroom(
    p: {
      classroomId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_classroom> | Res<404, t_basic_error>>
  > {
    const url = this.basePath + `/classrooms/${p["classroomId"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async classroomListAssignmentsForAClassroom(
    p: {
      classroomId: number
      page?: number
      perPage?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_simple_classroom_assignment[]>>> {
    const url = this.basePath + `/classrooms/${p["classroomId"]}/assignments`
    const query = this._query({page: p["page"], per_page: p["perPage"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async codesOfConductGetAllCodesOfConduct(
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_code_of_conduct[]> | Res<304, void>>
  > {
    const url = this.basePath + `/codes_of_conduct`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async codesOfConductGetConductCode(
    p: {
      key: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_code_of_conduct> | Res<304, void> | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/codes_of_conduct/${p["key"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async emojisGet(
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_emojisGetJson200Response> | Res<304, void>>
  > {
    const url = this.basePath + `/emojis`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async dependabotListAlertsForEnterprise(
    p: {
      enterprise: string
      state?: string
      severity?: string
      ecosystem?: string
      package?: string
      scope?: "development" | "runtime"
      sort?: "created" | "updated"
      direction?: "asc" | "desc"
      before?: string
      after?: string
      first?: number
      last?: number
      perPage?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_dependabot_alert_with_repository[]>
      | Res<304, void>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error_simple>
    >
  > {
    const url =
      this.basePath + `/enterprises/${p["enterprise"]}/dependabot/alerts`
    const query = this._query({
      state: p["state"],
      severity: p["severity"],
      ecosystem: p["ecosystem"],
      package: p["package"],
      scope: p["scope"],
      sort: p["sort"],
      direction: p["direction"],
      before: p["before"],
      after: p["after"],
      first: p["first"],
      last: p["last"],
      per_page: p["perPage"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async secretScanningListAlertsForEnterprise(
    p: {
      enterprise: string
      state?: "open" | "resolved"
      secretType?: string
      resolution?: string
      sort?: "created" | "updated"
      direction?: "asc" | "desc"
      perPage?: number
      before?: string
      after?: string
      validity?: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_organization_secret_scanning_alert[]>
      | Res<404, t_basic_error>
      | Res<503, t_secretScanningListAlertsForEnterpriseJson503Response>
    >
  > {
    const url =
      this.basePath + `/enterprises/${p["enterprise"]}/secret-scanning/alerts`
    const query = this._query({
      state: p["state"],
      secret_type: p["secretType"],
      resolution: p["resolution"],
      sort: p["sort"],
      direction: p["direction"],
      per_page: p["perPage"],
      before: p["before"],
      after: p["after"],
      validity: p["validity"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async activityListPublicEvents(
    p: {
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_event[]>
      | Res<304, void>
      | Res<403, t_basic_error>
      | Res<503, t_activityListPublicEventsJson503Response>
    >
  > {
    const url = this.basePath + `/events`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async activityGetFeeds(
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_feed>>> {
    const url = this.basePath + `/feeds`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async gistsList(
    p: {
      since?: string
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_base_gist[]> | Res<304, void> | Res<403, t_basic_error>
    >
  > {
    const url = this.basePath + `/gists`
    const query = this._query({
      since: p["since"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async gistsCreate(
    p: {
      requestBody: t_gistsCreateJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_gist_simple>
      | Res<304, void>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/gists`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async gistsListPublic(
    p: {
      since?: string
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_base_gist[]>
      | Res<304, void>
      | Res<403, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/gists/public`
    const query = this._query({
      since: p["since"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async gistsListStarred(
    p: {
      since?: string
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_base_gist[]>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
    >
  > {
    const url = this.basePath + `/gists/starred`
    const query = this._query({
      since: p["since"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async gistsGet(
    p: {
      gistId: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_gist_simple>
      | Res<304, void>
      | Res<403, t_gistsGetJson403Response>
      | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/gists/${p["gistId"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async gistsUpdate(
    p: {
      gistId: string
      requestBody: t_gistsUpdateJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_gist_simple>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/gists/${p["gistId"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PATCH", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async gistsDelete(
    p: {
      gistId: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<304, void>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/gists/${p["gistId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async gistsListComments(
    p: {
      gistId: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_gist_comment[]>
      | Res<304, void>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/gists/${p["gistId"]}/comments`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async gistsCreateComment(
    p: {
      gistId: string
      requestBody: t_gistsCreateCommentJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_gist_comment>
      | Res<304, void>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/gists/${p["gistId"]}/comments`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async gistsGetComment(
    p: {
      gistId: string
      commentId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_gist_comment>
      | Res<304, void>
      | Res<403, t_gistsGetCommentJson403Response>
      | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath + `/gists/${p["gistId"]}/comments/${p["commentId"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async gistsUpdateComment(
    p: {
      gistId: string
      commentId: number
      requestBody: t_gistsUpdateCommentJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_gist_comment> | Res<404, t_basic_error>>
  > {
    const url =
      this.basePath + `/gists/${p["gistId"]}/comments/${p["commentId"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PATCH", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async gistsDeleteComment(
    p: {
      gistId: string
      commentId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<304, void>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath + `/gists/${p["gistId"]}/comments/${p["commentId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async gistsListCommits(
    p: {
      gistId: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_gist_commit[]>
      | Res<304, void>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/gists/${p["gistId"]}/commits`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async gistsListForks(
    p: {
      gistId: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_gist_simple[]>
      | Res<304, void>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/gists/${p["gistId"]}/forks`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async gistsFork(
    p: {
      gistId: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_base_gist>
      | Res<304, void>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/gists/${p["gistId"]}/forks`

    return this._fetch(url, {method: "POST", ...(opts ?? {})}, timeout)
  }

  async gistsCheckIsStarred(
    p: {
      gistId: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<304, void>
      | Res<403, t_basic_error>
      | Res<404, t_gistsCheckIsStarredJson404Response>
    >
  > {
    const url = this.basePath + `/gists/${p["gistId"]}/star`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async gistsStar(
    p: {
      gistId: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<304, void>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/gists/${p["gistId"]}/star`

    return this._fetch(url, {method: "PUT", ...(opts ?? {})}, timeout)
  }

  async gistsUnstar(
    p: {
      gistId: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<304, void>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/gists/${p["gistId"]}/star`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async gistsGetRevision(
    p: {
      gistId: string
      sha: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_gist_simple>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/gists/${p["gistId"]}/${p["sha"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async gitignoreGetAllTemplates(
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, string[]> | Res<304, void>>> {
    const url = this.basePath + `/gitignore/templates`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async gitignoreGetTemplate(
    p: {
      name: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_gitignore_template> | Res<304, void>>
  > {
    const url = this.basePath + `/gitignore/templates/${p["name"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async appsListReposAccessibleToInstallation(
    p: {
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_appsListReposAccessibleToInstallationJson200Response>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
    >
  > {
    const url = this.basePath + `/installation/repositories`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async appsRevokeInstallationAccessToken(
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url = this.basePath + `/installation/token`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async issuesList(
    p: {
      filter?:
        | "assigned"
        | "created"
        | "mentioned"
        | "subscribed"
        | "repos"
        | "all"
      state?: "open" | "closed" | "all"
      labels?: string
      sort?: "created" | "updated" | "comments"
      direction?: "asc" | "desc"
      since?: string
      collab?: boolean
      orgs?: boolean
      owned?: boolean
      pulls?: boolean
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_issue[]>
      | Res<304, void>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/issues`
    const query = this._query({
      filter: p["filter"],
      state: p["state"],
      labels: p["labels"],
      sort: p["sort"],
      direction: p["direction"],
      since: p["since"],
      collab: p["collab"],
      orgs: p["orgs"],
      owned: p["owned"],
      pulls: p["pulls"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async licensesGetAllCommonlyUsed(
    p: {
      featured?: boolean
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_license_simple[]> | Res<304, void>>
  > {
    const url = this.basePath + `/licenses`
    const query = this._query({
      featured: p["featured"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async licensesGet(
    p: {
      license: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_license>
      | Res<304, void>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/licenses/${p["license"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async markdownRender(
    p: {
      requestBody: t_markdownRenderJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, string> | Res<304, void>>> {
    const url = this.basePath + `/markdown`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async markdownRenderRaw(
    p: {
      requestBody?: string
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, string> | Res<304, void>>> {
    const url = this.basePath + `/markdown/raw`
    const headers = this._headers({"Content-Type": "text/plain"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async appsGetSubscriptionPlanForAccount(
    p: {
      accountId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_marketplace_purchase>
      | Res<401, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath + `/marketplace_listing/accounts/${p["accountId"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async appsListPlans(
    p: {
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_marketplace_listing_plan[]>
      | Res<401, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/marketplace_listing/plans`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async appsListAccountsForPlan(
    p: {
      planId: number
      sort?: "created" | "updated"
      direction?: "asc" | "desc"
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_marketplace_purchase[]>
      | Res<401, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath + `/marketplace_listing/plans/${p["planId"]}/accounts`
    const query = this._query({
      sort: p["sort"],
      direction: p["direction"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async appsGetSubscriptionPlanForAccountStubbed(
    p: {
      accountId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_marketplace_purchase>
      | Res<401, t_basic_error>
      | Res<404, void>
    >
  > {
    const url =
      this.basePath + `/marketplace_listing/stubbed/accounts/${p["accountId"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async appsListPlansStubbed(
    p: {
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_marketplace_listing_plan[]> | Res<401, t_basic_error>
    >
  > {
    const url = this.basePath + `/marketplace_listing/stubbed/plans`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async appsListAccountsForPlanStubbed(
    p: {
      planId: number
      sort?: "created" | "updated"
      direction?: "asc" | "desc"
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_marketplace_purchase[]> | Res<401, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/marketplace_listing/stubbed/plans/${p["planId"]}/accounts`
    const query = this._query({
      sort: p["sort"],
      direction: p["direction"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async metaGet(
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_api_overview> | Res<304, void>>> {
    const url = this.basePath + `/meta`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async activityListPublicEventsForRepoNetwork(
    p: {
      owner: string
      repo: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_event[]>
      | Res<301, t_basic_error>
      | Res<304, void>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/networks/${p["owner"]}/${p["repo"]}/events`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async activityListNotificationsForAuthenticatedUser(
    p: {
      all?: boolean
      participating?: boolean
      since?: string
      before?: string
      page?: number
      perPage?: number
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_thread[]>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/notifications`
    const query = this._query({
      all: p["all"],
      participating: p["participating"],
      since: p["since"],
      before: p["before"],
      page: p["page"],
      per_page: p["perPage"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async activityMarkNotificationsAsRead(
    p: {
      requestBody?: t_activityMarkNotificationsAsReadJsonRequestBody
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<202, t_activityMarkNotificationsAsReadJson202Response>
      | Res<205, void>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
    >
  > {
    const url = this.basePath + `/notifications`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async activityGetThread(
    p: {
      threadId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_thread>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
    >
  > {
    const url = this.basePath + `/notifications/threads/${p["threadId"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async activityMarkThreadAsRead(
    p: {
      threadId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<205, void> | Res<304, void> | Res<403, t_basic_error>
    >
  > {
    const url = this.basePath + `/notifications/threads/${p["threadId"]}`

    return this._fetch(url, {method: "PATCH", ...(opts ?? {})}, timeout)
  }

  async activityMarkThreadAsDone(
    p: {
      threadId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url = this.basePath + `/notifications/threads/${p["threadId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async activityGetThreadSubscriptionForAuthenticatedUser(
    p: {
      threadId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_thread_subscription>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
    >
  > {
    const url =
      this.basePath + `/notifications/threads/${p["threadId"]}/subscription`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async activitySetThreadSubscription(
    p: {
      threadId: number
      requestBody?: t_activitySetThreadSubscriptionJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_thread_subscription>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
    >
  > {
    const url =
      this.basePath + `/notifications/threads/${p["threadId"]}/subscription`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async activityDeleteThreadSubscription(
    p: {
      threadId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
    >
  > {
    const url =
      this.basePath + `/notifications/threads/${p["threadId"]}/subscription`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async metaGetOctocat(
    p: {
      s?: string
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, string>>> {
    const url = this.basePath + `/octocat`
    const query = this._query({s: p["s"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async orgsList(
    p: {
      since?: number
      perPage?: number
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_organization_simple[]> | Res<304, void>>
  > {
    const url = this.basePath + `/organizations`
    const query = this._query({since: p["since"], per_page: p["perPage"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async orgsGet(
    p: {
      org: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_organization_full> | Res<404, t_basic_error>>
  > {
    const url = this.basePath + `/orgs/${p["org"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async orgsUpdate(
    p: {
      org: string
      requestBody?: t_orgsUpdateJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_organization_full>
      | Res<409, t_basic_error>
      | Res<422, t_orgsUpdateJson422Response>
    >
  > {
    const url = this.basePath + `/orgs/${p["org"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PATCH", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async orgsDelete(
    p: {
      org: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<202, t_orgsDeleteJson202Response>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/orgs/${p["org"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async actionsGetActionsCacheUsageForOrg(
    p: {
      org: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_actions_cache_usage_org_enterprise>>
  > {
    const url = this.basePath + `/orgs/${p["org"]}/actions/cache/usage`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsGetActionsCacheUsageByRepoForOrg(
    p: {
      org: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_actionsGetActionsCacheUsageByRepoForOrgJson200Response>
    >
  > {
    const url =
      this.basePath + `/orgs/${p["org"]}/actions/cache/usage-by-repository`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async oidcGetOidcCustomSubTemplateForOrg(
    p: {
      org: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_oidc_custom_sub>>> {
    const url =
      this.basePath + `/orgs/${p["org"]}/actions/oidc/customization/sub`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async oidcUpdateOidcCustomSubTemplateForOrg(
    p: {
      org: string
      requestBody: t_oidc_custom_sub
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_empty_object>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath + `/orgs/${p["org"]}/actions/oidc/customization/sub`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async actionsGetGithubActionsPermissionsOrganization(
    p: {
      org: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_actions_organization_permissions>>> {
    const url = this.basePath + `/orgs/${p["org"]}/actions/permissions`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsSetGithubActionsPermissionsOrganization(
    p: {
      org: string
      requestBody: t_actionsSetGithubActionsPermissionsOrganizationJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url = this.basePath + `/orgs/${p["org"]}/actions/permissions`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async actionsListSelectedRepositoriesEnabledGithubActionsOrganization(
    p: {
      org: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<
        200,
        t_actionsListSelectedRepositoriesEnabledGithubActionsOrganizationJson200Response
      >
    >
  > {
    const url =
      this.basePath + `/orgs/${p["org"]}/actions/permissions/repositories`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsSetSelectedRepositoriesEnabledGithubActionsOrganization(
    p: {
      org: string
      requestBody: t_actionsSetSelectedRepositoriesEnabledGithubActionsOrganizationJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath + `/orgs/${p["org"]}/actions/permissions/repositories`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async actionsEnableSelectedRepositoryGithubActionsOrganization(
    p: {
      org: string
      repositoryId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/actions/permissions/repositories/${p["repositoryId"]}`

    return this._fetch(url, {method: "PUT", ...(opts ?? {})}, timeout)
  }

  async actionsDisableSelectedRepositoryGithubActionsOrganization(
    p: {
      org: string
      repositoryId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/actions/permissions/repositories/${p["repositoryId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async actionsGetAllowedActionsOrganization(
    p: {
      org: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_selected_actions>>> {
    const url =
      this.basePath + `/orgs/${p["org"]}/actions/permissions/selected-actions`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsSetAllowedActionsOrganization(
    p: {
      org: string
      requestBody?: t_selected_actions
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath + `/orgs/${p["org"]}/actions/permissions/selected-actions`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async actionsGetGithubActionsDefaultWorkflowPermissionsOrganization(
    p: {
      org: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_actions_get_default_workflow_permissions>>
  > {
    const url = this.basePath + `/orgs/${p["org"]}/actions/permissions/workflow`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsSetGithubActionsDefaultWorkflowPermissionsOrganization(
    p: {
      org: string
      requestBody?: t_actions_set_default_workflow_permissions
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url = this.basePath + `/orgs/${p["org"]}/actions/permissions/workflow`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async actionsListSelfHostedRunnersForOrg(
    p: {
      name?: string
      org: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_actionsListSelfHostedRunnersForOrgJson200Response>
    >
  > {
    const url = this.basePath + `/orgs/${p["org"]}/actions/runners`
    const query = this._query({
      name: p["name"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsListRunnerApplicationsForOrg(
    p: {
      org: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_runner_application[]>>> {
    const url = this.basePath + `/orgs/${p["org"]}/actions/runners/downloads`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsGenerateRunnerJitconfigForOrg(
    p: {
      org: string
      requestBody: t_actionsGenerateRunnerJitconfigForOrgJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_actionsGenerateRunnerJitconfigForOrgJson201Response>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error_simple>
    >
  > {
    const url =
      this.basePath + `/orgs/${p["org"]}/actions/runners/generate-jitconfig`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async actionsCreateRegistrationTokenForOrg(
    p: {
      org: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<201, t_authentication_token>>> {
    const url =
      this.basePath + `/orgs/${p["org"]}/actions/runners/registration-token`

    return this._fetch(url, {method: "POST", ...(opts ?? {})}, timeout)
  }

  async actionsCreateRemoveTokenForOrg(
    p: {
      org: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<201, t_authentication_token>>> {
    const url = this.basePath + `/orgs/${p["org"]}/actions/runners/remove-token`

    return this._fetch(url, {method: "POST", ...(opts ?? {})}, timeout)
  }

  async actionsGetSelfHostedRunnerForOrg(
    p: {
      org: string
      runnerId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_runner>>> {
    const url =
      this.basePath + `/orgs/${p["org"]}/actions/runners/${p["runnerId"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsDeleteSelfHostedRunnerFromOrg(
    p: {
      org: string
      runnerId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath + `/orgs/${p["org"]}/actions/runners/${p["runnerId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async actionsListLabelsForSelfHostedRunnerForOrg(
    p: {
      org: string
      runnerId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_actionsListLabelsForSelfHostedRunnerForOrgJson200Response>
      | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/actions/runners/${p["runnerId"]}/labels`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsAddCustomLabelsToSelfHostedRunnerForOrg(
    p: {
      org: string
      runnerId: number
      requestBody: t_actionsAddCustomLabelsToSelfHostedRunnerForOrgJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          t_actionsAddCustomLabelsToSelfHostedRunnerForOrgJson200Response
        >
      | Res<404, t_basic_error>
      | Res<422, t_validation_error_simple>
    >
  > {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/actions/runners/${p["runnerId"]}/labels`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async actionsSetCustomLabelsForSelfHostedRunnerForOrg(
    p: {
      org: string
      runnerId: number
      requestBody: t_actionsSetCustomLabelsForSelfHostedRunnerForOrgJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          t_actionsSetCustomLabelsForSelfHostedRunnerForOrgJson200Response
        >
      | Res<404, t_basic_error>
      | Res<422, t_validation_error_simple>
    >
  > {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/actions/runners/${p["runnerId"]}/labels`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg(
    p: {
      org: string
      runnerId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          t_actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgJson200Response
        >
      | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/actions/runners/${p["runnerId"]}/labels`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async actionsRemoveCustomLabelFromSelfHostedRunnerForOrg(
    p: {
      org: string
      runnerId: number
      name: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          t_actionsRemoveCustomLabelFromSelfHostedRunnerForOrgJson200Response
        >
      | Res<404, t_basic_error>
      | Res<422, t_validation_error_simple>
    >
  > {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/actions/runners/${p["runnerId"]}/labels/${p["name"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async actionsListOrgSecrets(
    p: {
      org: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_actionsListOrgSecretsJson200Response>>
  > {
    const url = this.basePath + `/orgs/${p["org"]}/actions/secrets`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsGetOrgPublicKey(
    p: {
      org: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_actions_public_key>>> {
    const url = this.basePath + `/orgs/${p["org"]}/actions/secrets/public-key`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsGetOrgSecret(
    p: {
      org: string
      secretName: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_organization_actions_secret>>> {
    const url =
      this.basePath + `/orgs/${p["org"]}/actions/secrets/${p["secretName"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsCreateOrUpdateOrgSecret(
    p: {
      org: string
      secretName: string
      requestBody: t_actionsCreateOrUpdateOrgSecretJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<201, t_empty_object> | Res<204, void>>> {
    const url =
      this.basePath + `/orgs/${p["org"]}/actions/secrets/${p["secretName"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async actionsDeleteOrgSecret(
    p: {
      org: string
      secretName: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath + `/orgs/${p["org"]}/actions/secrets/${p["secretName"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async actionsListSelectedReposForOrgSecret(
    p: {
      org: string
      secretName: string
      page?: number
      perPage?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_actionsListSelectedReposForOrgSecretJson200Response>
    >
  > {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/actions/secrets/${p["secretName"]}/repositories`
    const query = this._query({page: p["page"], per_page: p["perPage"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsSetSelectedReposForOrgSecret(
    p: {
      org: string
      secretName: string
      requestBody: t_actionsSetSelectedReposForOrgSecretJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/actions/secrets/${p["secretName"]}/repositories`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async actionsAddSelectedRepoToOrgSecret(
    p: {
      org: string
      secretName: string
      repositoryId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void> | Res<409, void>>> {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/actions/secrets/${p["secretName"]}/repositories/${p["repositoryId"]}`

    return this._fetch(url, {method: "PUT", ...(opts ?? {})}, timeout)
  }

  async actionsRemoveSelectedRepoFromOrgSecret(
    p: {
      org: string
      secretName: string
      repositoryId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void> | Res<409, void>>> {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/actions/secrets/${p["secretName"]}/repositories/${p["repositoryId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async actionsListOrgVariables(
    p: {
      org: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_actionsListOrgVariablesJson200Response>>
  > {
    const url = this.basePath + `/orgs/${p["org"]}/actions/variables`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsCreateOrgVariable(
    p: {
      org: string
      requestBody: t_actionsCreateOrgVariableJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<201, t_empty_object>>> {
    const url = this.basePath + `/orgs/${p["org"]}/actions/variables`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async actionsGetOrgVariable(
    p: {
      org: string
      name: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_organization_actions_variable>>> {
    const url =
      this.basePath + `/orgs/${p["org"]}/actions/variables/${p["name"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsUpdateOrgVariable(
    p: {
      org: string
      name: string
      requestBody: t_actionsUpdateOrgVariableJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath + `/orgs/${p["org"]}/actions/variables/${p["name"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PATCH", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async actionsDeleteOrgVariable(
    p: {
      org: string
      name: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath + `/orgs/${p["org"]}/actions/variables/${p["name"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async actionsListSelectedReposForOrgVariable(
    p: {
      org: string
      name: string
      page?: number
      perPage?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_actionsListSelectedReposForOrgVariableJson200Response>
      | Res<409, void>
    >
  > {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/actions/variables/${p["name"]}/repositories`
    const query = this._query({page: p["page"], per_page: p["perPage"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsSetSelectedReposForOrgVariable(
    p: {
      org: string
      name: string
      requestBody: t_actionsSetSelectedReposForOrgVariableJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void> | Res<409, void>>> {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/actions/variables/${p["name"]}/repositories`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async actionsAddSelectedRepoToOrgVariable(
    p: {
      org: string
      name: string
      repositoryId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void> | Res<409, void>>> {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/actions/variables/${p["name"]}/repositories/${p["repositoryId"]}`

    return this._fetch(url, {method: "PUT", ...(opts ?? {})}, timeout)
  }

  async actionsRemoveSelectedRepoFromOrgVariable(
    p: {
      org: string
      name: string
      repositoryId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void> | Res<409, void>>> {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/actions/variables/${p["name"]}/repositories/${p["repositoryId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async orgsListBlockedUsers(
    p: {
      org: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_simple_user[]>>> {
    const url = this.basePath + `/orgs/${p["org"]}/blocks`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async orgsCheckBlockedUser(
    p: {
      org: string
      username: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void> | Res<404, t_basic_error>>> {
    const url = this.basePath + `/orgs/${p["org"]}/blocks/${p["username"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async orgsBlockUser(
    p: {
      org: string
      username: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<204, void> | Res<422, t_validation_error>>
  > {
    const url = this.basePath + `/orgs/${p["org"]}/blocks/${p["username"]}`

    return this._fetch(url, {method: "PUT", ...(opts ?? {})}, timeout)
  }

  async orgsUnblockUser(
    p: {
      org: string
      username: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url = this.basePath + `/orgs/${p["org"]}/blocks/${p["username"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async codeScanningListAlertsForOrg(
    p: {
      org: string
      toolName?: t_code_scanning_analysis_tool_name
      toolGuid?: t_code_scanning_analysis_tool_guid
      before?: string
      after?: string
      page?: number
      perPage?: number
      direction?: "asc" | "desc"
      state?: t_code_scanning_alert_state_query
      sort?: "created" | "updated"
      severity?: t_code_scanning_alert_severity
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_code_scanning_organization_alert_items[]>
      | Res<404, t_basic_error>
      | Res<503, t_codeScanningListAlertsForOrgJson503Response>
    >
  > {
    const url = this.basePath + `/orgs/${p["org"]}/code-scanning/alerts`
    const query = this._query({
      tool_name: p["toolName"],
      tool_guid: p["toolGuid"],
      before: p["before"],
      after: p["after"],
      page: p["page"],
      per_page: p["perPage"],
      direction: p["direction"],
      state: p["state"],
      sort: p["sort"],
      severity: p["severity"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async codespacesListInOrganization(
    p: {
      perPage?: number
      page?: number
      org: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_codespacesListInOrganizationJson200Response>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<500, t_basic_error>
    >
  > {
    const url = this.basePath + `/orgs/${p["org"]}/codespaces`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async codespacesSetCodespacesAccess(
    p: {
      org: string
      requestBody: t_codespacesSetCodespacesAccessJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<304, void>
      | Res<400, void>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
      | Res<500, t_basic_error>
    >
  > {
    const url = this.basePath + `/orgs/${p["org"]}/codespaces/access`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async codespacesSetCodespacesAccessUsers(
    p: {
      org: string
      requestBody: t_codespacesSetCodespacesAccessUsersJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<304, void>
      | Res<400, void>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
      | Res<500, t_basic_error>
    >
  > {
    const url =
      this.basePath + `/orgs/${p["org"]}/codespaces/access/selected_users`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async codespacesDeleteCodespacesAccessUsers(
    p: {
      org: string
      requestBody: t_codespacesDeleteCodespacesAccessUsersJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<304, void>
      | Res<400, void>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
      | Res<500, t_basic_error>
    >
  > {
    const url =
      this.basePath + `/orgs/${p["org"]}/codespaces/access/selected_users`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "DELETE", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async codespacesListOrgSecrets(
    p: {
      org: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_codespacesListOrgSecretsJson200Response>>
  > {
    const url = this.basePath + `/orgs/${p["org"]}/codespaces/secrets`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async codespacesGetOrgPublicKey(
    p: {
      org: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_codespaces_public_key>>> {
    const url =
      this.basePath + `/orgs/${p["org"]}/codespaces/secrets/public-key`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async codespacesGetOrgSecret(
    p: {
      org: string
      secretName: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_codespaces_org_secret>>> {
    const url =
      this.basePath + `/orgs/${p["org"]}/codespaces/secrets/${p["secretName"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async codespacesCreateOrUpdateOrgSecret(
    p: {
      org: string
      secretName: string
      requestBody: t_codespacesCreateOrUpdateOrgSecretJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_empty_object>
      | Res<204, void>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath + `/orgs/${p["org"]}/codespaces/secrets/${p["secretName"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async codespacesDeleteOrgSecret(
    p: {
      org: string
      secretName: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void> | Res<404, t_basic_error>>> {
    const url =
      this.basePath + `/orgs/${p["org"]}/codespaces/secrets/${p["secretName"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async codespacesListSelectedReposForOrgSecret(
    p: {
      org: string
      secretName: string
      page?: number
      perPage?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_codespacesListSelectedReposForOrgSecretJson200Response>
      | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/codespaces/secrets/${p["secretName"]}/repositories`
    const query = this._query({page: p["page"], per_page: p["perPage"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async codespacesSetSelectedReposForOrgSecret(
    p: {
      org: string
      secretName: string
      requestBody: t_codespacesSetSelectedReposForOrgSecretJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<204, void> | Res<404, t_basic_error> | Res<409, void>
    >
  > {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/codespaces/secrets/${p["secretName"]}/repositories`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async codespacesAddSelectedRepoToOrgSecret(
    p: {
      org: string
      secretName: string
      repositoryId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<404, t_basic_error>
      | Res<409, void>
      | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/codespaces/secrets/${p["secretName"]}/repositories/${p["repositoryId"]}`

    return this._fetch(url, {method: "PUT", ...(opts ?? {})}, timeout)
  }

  async codespacesRemoveSelectedRepoFromOrgSecret(
    p: {
      org: string
      secretName: string
      repositoryId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<404, t_basic_error>
      | Res<409, void>
      | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/codespaces/secrets/${p["secretName"]}/repositories/${p["repositoryId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async copilotGetCopilotOrganizationDetails(
    p: {
      org: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_copilot_organization_details>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, void>
      | Res<500, t_basic_error>
    >
  > {
    const url = this.basePath + `/orgs/${p["org"]}/copilot/billing`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async copilotListCopilotSeats(
    p: {
      org: string
      page?: number
      perPage?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_copilotListCopilotSeatsJson200Response>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<500, t_basic_error>
    >
  > {
    const url = this.basePath + `/orgs/${p["org"]}/copilot/billing/seats`
    const query = this._query({page: p["page"], per_page: p["perPage"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async copilotAddCopilotSeatsForTeams(
    p: {
      org: string
      requestBody: t_copilotAddCopilotSeatsForTeamsJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_copilotAddCopilotSeatsForTeamsJson201Response>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, void>
      | Res<500, t_basic_error>
    >
  > {
    const url =
      this.basePath + `/orgs/${p["org"]}/copilot/billing/selected_teams`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async copilotCancelCopilotSeatAssignmentForTeams(
    p: {
      org: string
      requestBody: t_copilotCancelCopilotSeatAssignmentForTeamsJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_copilotCancelCopilotSeatAssignmentForTeamsJson200Response>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, void>
      | Res<500, t_basic_error>
    >
  > {
    const url =
      this.basePath + `/orgs/${p["org"]}/copilot/billing/selected_teams`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "DELETE", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async copilotAddCopilotSeatsForUsers(
    p: {
      org: string
      requestBody: t_copilotAddCopilotSeatsForUsersJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_copilotAddCopilotSeatsForUsersJson201Response>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, void>
      | Res<500, t_basic_error>
    >
  > {
    const url =
      this.basePath + `/orgs/${p["org"]}/copilot/billing/selected_users`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async copilotCancelCopilotSeatAssignmentForUsers(
    p: {
      org: string
      requestBody: t_copilotCancelCopilotSeatAssignmentForUsersJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_copilotCancelCopilotSeatAssignmentForUsersJson200Response>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, void>
      | Res<500, t_basic_error>
    >
  > {
    const url =
      this.basePath + `/orgs/${p["org"]}/copilot/billing/selected_users`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "DELETE", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async dependabotListAlertsForOrg(
    p: {
      org: string
      state?: string
      severity?: string
      ecosystem?: string
      package?: string
      scope?: "development" | "runtime"
      sort?: "created" | "updated"
      direction?: "asc" | "desc"
      before?: string
      after?: string
      first?: number
      last?: number
      perPage?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_dependabot_alert_with_repository[]>
      | Res<304, void>
      | Res<400, t_scim_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error_simple>
    >
  > {
    const url = this.basePath + `/orgs/${p["org"]}/dependabot/alerts`
    const query = this._query({
      state: p["state"],
      severity: p["severity"],
      ecosystem: p["ecosystem"],
      package: p["package"],
      scope: p["scope"],
      sort: p["sort"],
      direction: p["direction"],
      before: p["before"],
      after: p["after"],
      first: p["first"],
      last: p["last"],
      per_page: p["perPage"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async dependabotListOrgSecrets(
    p: {
      org: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_dependabotListOrgSecretsJson200Response>>
  > {
    const url = this.basePath + `/orgs/${p["org"]}/dependabot/secrets`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async dependabotGetOrgPublicKey(
    p: {
      org: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_dependabot_public_key>>> {
    const url =
      this.basePath + `/orgs/${p["org"]}/dependabot/secrets/public-key`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async dependabotGetOrgSecret(
    p: {
      org: string
      secretName: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_organization_dependabot_secret>>> {
    const url =
      this.basePath + `/orgs/${p["org"]}/dependabot/secrets/${p["secretName"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async dependabotCreateOrUpdateOrgSecret(
    p: {
      org: string
      secretName: string
      requestBody: t_dependabotCreateOrUpdateOrgSecretJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<201, t_empty_object> | Res<204, void>>> {
    const url =
      this.basePath + `/orgs/${p["org"]}/dependabot/secrets/${p["secretName"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async dependabotDeleteOrgSecret(
    p: {
      org: string
      secretName: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath + `/orgs/${p["org"]}/dependabot/secrets/${p["secretName"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async dependabotListSelectedReposForOrgSecret(
    p: {
      org: string
      secretName: string
      page?: number
      perPage?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_dependabotListSelectedReposForOrgSecretJson200Response>
    >
  > {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/dependabot/secrets/${p["secretName"]}/repositories`
    const query = this._query({page: p["page"], per_page: p["perPage"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async dependabotSetSelectedReposForOrgSecret(
    p: {
      org: string
      secretName: string
      requestBody: t_dependabotSetSelectedReposForOrgSecretJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/dependabot/secrets/${p["secretName"]}/repositories`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async dependabotAddSelectedRepoToOrgSecret(
    p: {
      org: string
      secretName: string
      repositoryId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void> | Res<409, void>>> {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/dependabot/secrets/${p["secretName"]}/repositories/${p["repositoryId"]}`

    return this._fetch(url, {method: "PUT", ...(opts ?? {})}, timeout)
  }

  async dependabotRemoveSelectedRepoFromOrgSecret(
    p: {
      org: string
      secretName: string
      repositoryId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void> | Res<409, void>>> {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/dependabot/secrets/${p["secretName"]}/repositories/${p["repositoryId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async packagesListDockerMigrationConflictingPackagesForOrganization(
    p: {
      org: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_package[]> | Res<401, t_basic_error> | Res<403, t_basic_error>
    >
  > {
    const url = this.basePath + `/orgs/${p["org"]}/docker/conflicts`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async activityListPublicOrgEvents(
    p: {
      org: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_event[]>>> {
    const url = this.basePath + `/orgs/${p["org"]}/events`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async orgsListFailedInvitations(
    p: {
      org: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_organization_invitation[]> | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/orgs/${p["org"]}/failed_invitations`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async orgsListWebhooks(
    p: {
      org: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_org_hook[]> | Res<404, t_basic_error>>
  > {
    const url = this.basePath + `/orgs/${p["org"]}/hooks`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async orgsCreateWebhook(
    p: {
      org: string
      requestBody: t_orgsCreateWebhookJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_org_hook>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/orgs/${p["org"]}/hooks`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async orgsGetWebhook(
    p: {
      org: string
      hookId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_org_hook> | Res<404, t_basic_error>>
  > {
    const url = this.basePath + `/orgs/${p["org"]}/hooks/${p["hookId"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async orgsUpdateWebhook(
    p: {
      org: string
      hookId: number
      requestBody?: t_orgsUpdateWebhookJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_org_hook>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/orgs/${p["org"]}/hooks/${p["hookId"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PATCH", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async orgsDeleteWebhook(
    p: {
      org: string
      hookId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void> | Res<404, t_basic_error>>> {
    const url = this.basePath + `/orgs/${p["org"]}/hooks/${p["hookId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async orgsGetWebhookConfigForOrg(
    p: {
      org: string
      hookId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_webhook_config>>> {
    const url = this.basePath + `/orgs/${p["org"]}/hooks/${p["hookId"]}/config`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async orgsUpdateWebhookConfigForOrg(
    p: {
      org: string
      hookId: number
      requestBody?: t_orgsUpdateWebhookConfigForOrgJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_webhook_config>>> {
    const url = this.basePath + `/orgs/${p["org"]}/hooks/${p["hookId"]}/config`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PATCH", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async orgsListWebhookDeliveries(
    p: {
      org: string
      hookId: number
      perPage?: number
      cursor?: string
      redelivery?: boolean
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_hook_delivery_item[]>
      | Res<400, t_scim_error>
      | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath + `/orgs/${p["org"]}/hooks/${p["hookId"]}/deliveries`
    const query = this._query({
      per_page: p["perPage"],
      cursor: p["cursor"],
      redelivery: p["redelivery"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async orgsGetWebhookDelivery(
    p: {
      org: string
      hookId: number
      deliveryId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_hook_delivery>
      | Res<400, t_scim_error>
      | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/hooks/${p["hookId"]}/deliveries/${p["deliveryId"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async orgsRedeliverWebhookDelivery(
    p: {
      org: string
      hookId: number
      deliveryId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<202, t_orgsRedeliverWebhookDeliveryJson202Response>
      | Res<400, t_scim_error>
      | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/hooks/${p["hookId"]}/deliveries/${p["deliveryId"]}/attempts`

    return this._fetch(url, {method: "POST", ...(opts ?? {})}, timeout)
  }

  async orgsPingWebhook(
    p: {
      org: string
      hookId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void> | Res<404, t_basic_error>>> {
    const url = this.basePath + `/orgs/${p["org"]}/hooks/${p["hookId"]}/pings`

    return this._fetch(url, {method: "POST", ...(opts ?? {})}, timeout)
  }

  async appsGetOrgInstallation(
    p: {
      org: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_installation>>> {
    const url = this.basePath + `/orgs/${p["org"]}/installation`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async orgsListAppInstallations(
    p: {
      org: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_orgsListAppInstallationsJson200Response>>
  > {
    const url = this.basePath + `/orgs/${p["org"]}/installations`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async interactionsGetRestrictionsForOrg(
    p: {
      org: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_interactionsGetRestrictionsForOrgJson200Response>
    >
  > {
    const url = this.basePath + `/orgs/${p["org"]}/interaction-limits`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async interactionsSetRestrictionsForOrg(
    p: {
      org: string
      requestBody: t_interaction_limit
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_interaction_limit_response> | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/orgs/${p["org"]}/interaction-limits`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async interactionsRemoveRestrictionsForOrg(
    p: {
      org: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url = this.basePath + `/orgs/${p["org"]}/interaction-limits`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async orgsListPendingInvitations(
    p: {
      org: string
      perPage?: number
      page?: number
      role?:
        | "all"
        | "admin"
        | "direct_member"
        | "billing_manager"
        | "hiring_manager"
      invitationSource?: "all" | "member" | "scim"
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_organization_invitation[]> | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/orgs/${p["org"]}/invitations`
    const query = this._query({
      per_page: p["perPage"],
      page: p["page"],
      role: p["role"],
      invitation_source: p["invitationSource"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async orgsCreateInvitation(
    p: {
      org: string
      requestBody?: t_orgsCreateInvitationJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_organization_invitation>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/orgs/${p["org"]}/invitations`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async orgsCancelInvitation(
    p: {
      org: string
      invitationId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<204, void> | Res<404, t_basic_error> | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath + `/orgs/${p["org"]}/invitations/${p["invitationId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async orgsListInvitationTeams(
    p: {
      org: string
      invitationId: number
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_team[]> | Res<404, t_basic_error>>> {
    const url =
      this.basePath + `/orgs/${p["org"]}/invitations/${p["invitationId"]}/teams`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async issuesListForOrg(
    p: {
      org: string
      filter?:
        | "assigned"
        | "created"
        | "mentioned"
        | "subscribed"
        | "repos"
        | "all"
      state?: "open" | "closed" | "all"
      labels?: string
      sort?: "created" | "updated" | "comments"
      direction?: "asc" | "desc"
      since?: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_issue[]> | Res<404, t_basic_error>>
  > {
    const url = this.basePath + `/orgs/${p["org"]}/issues`
    const query = this._query({
      filter: p["filter"],
      state: p["state"],
      labels: p["labels"],
      sort: p["sort"],
      direction: p["direction"],
      since: p["since"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async orgsListMembers(
    p: {
      org: string
      filter?: "2fa_disabled" | "all"
      role?: "all" | "admin" | "member"
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_simple_user[]> | Res<422, t_validation_error>>
  > {
    const url = this.basePath + `/orgs/${p["org"]}/members`
    const query = this._query({
      filter: p["filter"],
      role: p["role"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async orgsCheckMembershipForUser(
    p: {
      org: string
      username: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<204, void> | Res<302, void> | Res<404, void>>
  > {
    const url = this.basePath + `/orgs/${p["org"]}/members/${p["username"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async orgsRemoveMember(
    p: {
      org: string
      username: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void> | Res<403, t_basic_error>>> {
    const url = this.basePath + `/orgs/${p["org"]}/members/${p["username"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async codespacesGetCodespacesForUserInOrg(
    p: {
      perPage?: number
      page?: number
      org: string
      username: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_codespacesGetCodespacesForUserInOrgJson200Response>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<500, t_basic_error>
    >
  > {
    const url =
      this.basePath + `/orgs/${p["org"]}/members/${p["username"]}/codespaces`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async codespacesDeleteFromOrganization(
    p: {
      org: string
      username: string
      codespaceName: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<202, t_codespacesDeleteFromOrganizationJson202Response>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<500, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/members/${p["username"]}/codespaces/${p["codespaceName"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async codespacesStopInOrganization(
    p: {
      org: string
      username: string
      codespaceName: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_codespace>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<500, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/members/${p["username"]}/codespaces/${p["codespaceName"]}/stop`

    return this._fetch(url, {method: "POST", ...(opts ?? {})}, timeout)
  }

  async copilotGetCopilotSeatDetailsForUser(
    p: {
      org: string
      username: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_copilot_seat_details>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, void>
      | Res<500, t_basic_error>
    >
  > {
    const url =
      this.basePath + `/orgs/${p["org"]}/members/${p["username"]}/copilot`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async orgsGetMembershipForUser(
    p: {
      org: string
      username: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_org_membership>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/orgs/${p["org"]}/memberships/${p["username"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async orgsSetMembershipForUser(
    p: {
      org: string
      username: string
      requestBody?: t_orgsSetMembershipForUserJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_org_membership>
      | Res<403, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/orgs/${p["org"]}/memberships/${p["username"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async orgsRemoveMembershipForUser(
    p: {
      org: string
      username: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<204, void> | Res<403, t_basic_error> | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/orgs/${p["org"]}/memberships/${p["username"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async migrationsListForOrg(
    p: {
      org: string
      perPage?: number
      page?: number
      exclude?: "repositories"[]
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_migration[]>>> {
    const url = this.basePath + `/orgs/${p["org"]}/migrations`
    const query = this._query({
      per_page: p["perPage"],
      page: p["page"],
      exclude: p["exclude"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async migrationsStartForOrg(
    p: {
      org: string
      requestBody: t_migrationsStartForOrgJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_migration>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/orgs/${p["org"]}/migrations`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async migrationsGetStatusForOrg(
    p: {
      org: string
      migrationId: number
      exclude?: "repositories"[]
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_migration> | Res<404, t_basic_error>>
  > {
    const url =
      this.basePath + `/orgs/${p["org"]}/migrations/${p["migrationId"]}`
    const query = this._query({exclude: p["exclude"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async migrationsDownloadArchiveForOrg(
    p: {
      org: string
      migrationId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<302, void> | Res<404, t_basic_error>>> {
    const url =
      this.basePath + `/orgs/${p["org"]}/migrations/${p["migrationId"]}/archive`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async migrationsDeleteArchiveForOrg(
    p: {
      org: string
      migrationId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void> | Res<404, t_basic_error>>> {
    const url =
      this.basePath + `/orgs/${p["org"]}/migrations/${p["migrationId"]}/archive`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async migrationsUnlockRepoForOrg(
    p: {
      org: string
      migrationId: number
      repoName: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void> | Res<404, t_basic_error>>> {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/migrations/${p["migrationId"]}/repos/${p["repoName"]}/lock`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async migrationsListReposForOrg(
    p: {
      org: string
      migrationId: number
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_minimal_repository[]> | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/migrations/${p["migrationId"]}/repositories`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async orgsListOrganizationFineGrainedPermissions(
    p: {
      org: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_organization_fine_grained_permission[]>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath + `/orgs/${p["org"]}/organization-fine-grained-permissions`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async orgsListOrgRoles(
    p: {
      org: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_orgsListOrgRolesJson200Response>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/orgs/${p["org"]}/organization-roles`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async orgsCreateCustomOrganizationRole(
    p: {
      org: string
      requestBody: t_orgsCreateCustomOrganizationRoleJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_organization_role>
      | Res<404, t_basic_error>
      | Res<409, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/orgs/${p["org"]}/organization-roles`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async orgsRevokeAllOrgRolesTeam(
    p: {
      org: string
      teamSlug: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/organization-roles/teams/${p["teamSlug"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async orgsAssignTeamToOrgRole(
    p: {
      org: string
      teamSlug: string
      roleId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<204, void> | Res<404, void> | Res<422, void>>
  > {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/organization-roles/teams/${p["teamSlug"]}/${p["roleId"]}`

    return this._fetch(url, {method: "PUT", ...(opts ?? {})}, timeout)
  }

  async orgsRevokeOrgRoleTeam(
    p: {
      org: string
      teamSlug: string
      roleId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/organization-roles/teams/${p["teamSlug"]}/${p["roleId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async orgsRevokeAllOrgRolesUser(
    p: {
      org: string
      username: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/organization-roles/users/${p["username"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async orgsAssignUserToOrgRole(
    p: {
      org: string
      username: string
      roleId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<204, void> | Res<404, void> | Res<422, void>>
  > {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/organization-roles/users/${p["username"]}/${p["roleId"]}`

    return this._fetch(url, {method: "PUT", ...(opts ?? {})}, timeout)
  }

  async orgsRevokeOrgRoleUser(
    p: {
      org: string
      username: string
      roleId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/organization-roles/users/${p["username"]}/${p["roleId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async orgsGetOrgRole(
    p: {
      org: string
      roleId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_organization_role>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath + `/orgs/${p["org"]}/organization-roles/${p["roleId"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async orgsPatchCustomOrganizationRole(
    p: {
      org: string
      roleId: number
      requestBody: t_orgsPatchCustomOrganizationRoleJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_organization_role>
      | Res<404, t_basic_error>
      | Res<409, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath + `/orgs/${p["org"]}/organization-roles/${p["roleId"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PATCH", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async orgsDeleteCustomOrganizationRole(
    p: {
      org: string
      roleId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath + `/orgs/${p["org"]}/organization-roles/${p["roleId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async orgsListOrgRoleTeams(
    p: {
      org: string
      roleId: number
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_team[]> | Res<404, void> | Res<422, void>>
  > {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/organization-roles/${p["roleId"]}/teams`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async orgsListOrgRoleUsers(
    p: {
      org: string
      roleId: number
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_simple_user[]> | Res<404, void> | Res<422, void>
    >
  > {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/organization-roles/${p["roleId"]}/users`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async orgsListOutsideCollaborators(
    p: {
      org: string
      filter?: "2fa_disabled" | "all"
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_simple_user[]>>> {
    const url = this.basePath + `/orgs/${p["org"]}/outside_collaborators`
    const query = this._query({
      filter: p["filter"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async orgsConvertMemberToOutsideCollaborator(
    p: {
      org: string
      username: string
      requestBody?: t_orgsConvertMemberToOutsideCollaboratorJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<202, t_orgsConvertMemberToOutsideCollaboratorJson202Response>
      | Res<204, void>
      | Res<403, void>
      | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath + `/orgs/${p["org"]}/outside_collaborators/${p["username"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async orgsRemoveOutsideCollaborator(
    p: {
      org: string
      username: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<204, void> | Res<422, t_orgsRemoveOutsideCollaboratorJson422Response>
    >
  > {
    const url =
      this.basePath + `/orgs/${p["org"]}/outside_collaborators/${p["username"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async packagesListPackagesForOrganization(
    p: {
      packageType:
        | "npm"
        | "maven"
        | "rubygems"
        | "docker"
        | "nuget"
        | "container"
      org: string
      visibility?: "public" | "private" | "internal"
      page?: number
      perPage?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_package[]>
      | Res<400, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
    >
  > {
    const url = this.basePath + `/orgs/${p["org"]}/packages`
    const query = this._query({
      package_type: p["packageType"],
      visibility: p["visibility"],
      page: p["page"],
      per_page: p["perPage"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async packagesGetPackageForOrganization(
    p: {
      packageType:
        | "npm"
        | "maven"
        | "rubygems"
        | "docker"
        | "nuget"
        | "container"
      packageName: string
      org: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_package>>> {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/packages/${p["packageType"]}/${p["packageName"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async packagesDeletePackageForOrg(
    p: {
      packageType:
        | "npm"
        | "maven"
        | "rubygems"
        | "docker"
        | "nuget"
        | "container"
      packageName: string
      org: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/packages/${p["packageType"]}/${p["packageName"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async packagesRestorePackageForOrg(
    p: {
      packageType:
        | "npm"
        | "maven"
        | "rubygems"
        | "docker"
        | "nuget"
        | "container"
      packageName: string
      org: string
      token?: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/packages/${p["packageType"]}/${p["packageName"]}/restore`
    const query = this._query({token: p["token"]})

    return this._fetch(url + query, {method: "POST", ...(opts ?? {})}, timeout)
  }

  async packagesGetAllPackageVersionsForPackageOwnedByOrg(
    p: {
      packageType:
        | "npm"
        | "maven"
        | "rubygems"
        | "docker"
        | "nuget"
        | "container"
      packageName: string
      org: string
      page?: number
      perPage?: number
      state?: "active" | "deleted"
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_package_version[]>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/packages/${p["packageType"]}/${p["packageName"]}/versions`
    const query = this._query({
      page: p["page"],
      per_page: p["perPage"],
      state: p["state"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async packagesGetPackageVersionForOrganization(
    p: {
      packageType:
        | "npm"
        | "maven"
        | "rubygems"
        | "docker"
        | "nuget"
        | "container"
      packageName: string
      org: string
      packageVersionId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_package_version>>> {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/packages/${p["packageType"]}/${p["packageName"]}/versions/${p["packageVersionId"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async packagesDeletePackageVersionForOrg(
    p: {
      packageType:
        | "npm"
        | "maven"
        | "rubygems"
        | "docker"
        | "nuget"
        | "container"
      packageName: string
      org: string
      packageVersionId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/packages/${p["packageType"]}/${p["packageName"]}/versions/${p["packageVersionId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async packagesRestorePackageVersionForOrg(
    p: {
      packageType:
        | "npm"
        | "maven"
        | "rubygems"
        | "docker"
        | "nuget"
        | "container"
      packageName: string
      org: string
      packageVersionId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/packages/${p["packageType"]}/${p["packageName"]}/versions/${p["packageVersionId"]}/restore`

    return this._fetch(url, {method: "POST", ...(opts ?? {})}, timeout)
  }

  async orgsListPatGrantRequests(
    p: {
      org: string
      perPage?: number
      page?: number
      sort?: "created_at"
      direction?: "asc" | "desc"
      owner?: string[]
      repository?: string
      permission?: string
      lastUsedBefore?: string
      lastUsedAfter?: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_organization_programmatic_access_grant_request[]>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
      | Res<500, t_basic_error>
    >
  > {
    const url =
      this.basePath + `/orgs/${p["org"]}/personal-access-token-requests`
    const query = this._query({
      per_page: p["perPage"],
      page: p["page"],
      sort: p["sort"],
      direction: p["direction"],
      owner: p["owner"],
      repository: p["repository"],
      permission: p["permission"],
      last_used_before: p["lastUsedBefore"],
      last_used_after: p["lastUsedAfter"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async orgsReviewPatGrantRequestsInBulk(
    p: {
      org: string
      requestBody: t_orgsReviewPatGrantRequestsInBulkJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<202, t_orgsReviewPatGrantRequestsInBulkJson202Response>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
      | Res<500, t_basic_error>
    >
  > {
    const url =
      this.basePath + `/orgs/${p["org"]}/personal-access-token-requests`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async orgsReviewPatGrantRequest(
    p: {
      org: string
      patRequestId: number
      requestBody: t_orgsReviewPatGrantRequestJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
      | Res<500, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/personal-access-token-requests/${p["patRequestId"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async orgsListPatGrantRequestRepositories(
    p: {
      org: string
      patRequestId: number
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_minimal_repository[]>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<500, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/personal-access-token-requests/${p["patRequestId"]}/repositories`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async orgsListPatGrants(
    p: {
      org: string
      perPage?: number
      page?: number
      sort?: "created_at"
      direction?: "asc" | "desc"
      owner?: string[]
      repository?: string
      permission?: string
      lastUsedBefore?: string
      lastUsedAfter?: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_organization_programmatic_access_grant[]>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
      | Res<500, t_basic_error>
    >
  > {
    const url = this.basePath + `/orgs/${p["org"]}/personal-access-tokens`
    const query = this._query({
      per_page: p["perPage"],
      page: p["page"],
      sort: p["sort"],
      direction: p["direction"],
      owner: p["owner"],
      repository: p["repository"],
      permission: p["permission"],
      last_used_before: p["lastUsedBefore"],
      last_used_after: p["lastUsedAfter"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async orgsUpdatePatAccesses(
    p: {
      org: string
      requestBody: t_orgsUpdatePatAccessesJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<202, t_orgsUpdatePatAccessesJson202Response>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
      | Res<500, t_basic_error>
    >
  > {
    const url = this.basePath + `/orgs/${p["org"]}/personal-access-tokens`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async orgsUpdatePatAccess(
    p: {
      org: string
      patId: number
      requestBody: t_orgsUpdatePatAccessJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
      | Res<500, t_basic_error>
    >
  > {
    const url =
      this.basePath + `/orgs/${p["org"]}/personal-access-tokens/${p["patId"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async orgsListPatGrantRepositories(
    p: {
      org: string
      patId: number
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_minimal_repository[]>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<500, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/personal-access-tokens/${p["patId"]}/repositories`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async projectsListForOrg(
    p: {
      org: string
      state?: "open" | "closed" | "all"
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_project[]> | Res<422, t_validation_error_simple>
    >
  > {
    const url = this.basePath + `/orgs/${p["org"]}/projects`
    const query = this._query({
      state: p["state"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async projectsCreateForOrg(
    p: {
      org: string
      requestBody: t_projectsCreateForOrgJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_project>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<410, t_basic_error>
      | Res<422, t_validation_error_simple>
    >
  > {
    const url = this.basePath + `/orgs/${p["org"]}/projects`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async orgsGetAllCustomProperties(
    p: {
      org: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_org_custom_property[]>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/orgs/${p["org"]}/properties/schema`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async orgsCreateOrUpdateCustomProperties(
    p: {
      org: string
      requestBody: t_orgsCreateOrUpdateCustomPropertiesJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_org_custom_property[]>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/orgs/${p["org"]}/properties/schema`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PATCH", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async orgsGetCustomProperty(
    p: {
      org: string
      customPropertyName: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_org_custom_property>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/properties/schema/${p["customPropertyName"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async orgsCreateOrUpdateCustomProperty(
    p: {
      org: string
      customPropertyName: string
      requestBody: t_orgsCreateOrUpdateCustomPropertyJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_org_custom_property>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/properties/schema/${p["customPropertyName"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async orgsRemoveCustomProperty(
    p: {
      org: string
      customPropertyName: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<204, void> | Res<403, t_basic_error> | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/properties/schema/${p["customPropertyName"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async orgsListCustomPropertiesValuesForRepos(
    p: {
      org: string
      perPage?: number
      page?: number
      repositoryQuery?: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_org_repo_custom_property_values[]>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/orgs/${p["org"]}/properties/values`
    const query = this._query({
      per_page: p["perPage"],
      page: p["page"],
      repository_query: p["repositoryQuery"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async orgsCreateOrUpdateCustomPropertiesValuesForRepos(
    p: {
      org: string
      requestBody: t_orgsCreateOrUpdateCustomPropertiesValuesForReposJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/orgs/${p["org"]}/properties/values`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PATCH", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async orgsListPublicMembers(
    p: {
      org: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_simple_user[]>>> {
    const url = this.basePath + `/orgs/${p["org"]}/public_members`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async orgsCheckPublicMembershipForUser(
    p: {
      org: string
      username: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void> | Res<404, void>>> {
    const url =
      this.basePath + `/orgs/${p["org"]}/public_members/${p["username"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async orgsSetPublicMembershipForAuthenticatedUser(
    p: {
      org: string
      username: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void> | Res<403, t_basic_error>>> {
    const url =
      this.basePath + `/orgs/${p["org"]}/public_members/${p["username"]}`

    return this._fetch(url, {method: "PUT", ...(opts ?? {})}, timeout)
  }

  async orgsRemovePublicMembershipForAuthenticatedUser(
    p: {
      org: string
      username: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath + `/orgs/${p["org"]}/public_members/${p["username"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async reposListForOrg(
    p: {
      org: string
      type?: "all" | "public" | "private" | "forks" | "sources" | "member"
      sort?: "created" | "updated" | "pushed" | "full_name"
      direction?: "asc" | "desc"
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_minimal_repository[]>>> {
    const url = this.basePath + `/orgs/${p["org"]}/repos`
    const query = this._query({
      type: p["type"],
      sort: p["sort"],
      direction: p["direction"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposCreateInOrg(
    p: {
      org: string
      requestBody: t_reposCreateInOrgJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_full_repository>
      | Res<403, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/orgs/${p["org"]}/repos`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reposGetOrgRulesets(
    p: {
      org: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_repository_ruleset[]>
      | Res<404, t_basic_error>
      | Res<500, t_basic_error>
    >
  > {
    const url = this.basePath + `/orgs/${p["org"]}/rulesets`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposCreateOrgRuleset(
    p: {
      org: string
      requestBody: t_reposCreateOrgRulesetJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_repository_ruleset>
      | Res<404, t_basic_error>
      | Res<500, t_basic_error>
    >
  > {
    const url = this.basePath + `/orgs/${p["org"]}/rulesets`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reposGetOrgRuleSuites(
    p: {
      org: string
      repositoryName?: number
      timePeriod?: "hour" | "day" | "week" | "month"
      actorName?: string
      ruleSuiteResult?: "pass" | "fail" | "bypass" | "all"
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_rule_suites>
      | Res<404, t_basic_error>
      | Res<500, t_basic_error>
    >
  > {
    const url = this.basePath + `/orgs/${p["org"]}/rulesets/rule-suites`
    const query = this._query({
      repository_name: p["repositoryName"],
      time_period: p["timePeriod"],
      actor_name: p["actorName"],
      rule_suite_result: p["ruleSuiteResult"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposGetOrgRuleSuite(
    p: {
      org: string
      ruleSuiteId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_rule_suite> | Res<404, t_basic_error> | Res<500, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/rulesets/rule-suites/${p["ruleSuiteId"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposGetOrgRuleset(
    p: {
      org: string
      rulesetId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_repository_ruleset>
      | Res<404, t_basic_error>
      | Res<500, t_basic_error>
    >
  > {
    const url = this.basePath + `/orgs/${p["org"]}/rulesets/${p["rulesetId"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposUpdateOrgRuleset(
    p: {
      org: string
      rulesetId: number
      requestBody?: t_reposUpdateOrgRulesetJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_repository_ruleset>
      | Res<404, t_basic_error>
      | Res<500, t_basic_error>
    >
  > {
    const url = this.basePath + `/orgs/${p["org"]}/rulesets/${p["rulesetId"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reposDeleteOrgRuleset(
    p: {
      org: string
      rulesetId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<204, void> | Res<404, t_basic_error> | Res<500, t_basic_error>
    >
  > {
    const url = this.basePath + `/orgs/${p["org"]}/rulesets/${p["rulesetId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async secretScanningListAlertsForOrg(
    p: {
      org: string
      state?: "open" | "resolved"
      secretType?: string
      resolution?: string
      sort?: "created" | "updated"
      direction?: "asc" | "desc"
      page?: number
      perPage?: number
      before?: string
      after?: string
      validity?: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_organization_secret_scanning_alert[]>
      | Res<404, t_basic_error>
      | Res<503, t_secretScanningListAlertsForOrgJson503Response>
    >
  > {
    const url = this.basePath + `/orgs/${p["org"]}/secret-scanning/alerts`
    const query = this._query({
      state: p["state"],
      secret_type: p["secretType"],
      resolution: p["resolution"],
      sort: p["sort"],
      direction: p["direction"],
      page: p["page"],
      per_page: p["perPage"],
      before: p["before"],
      after: p["after"],
      validity: p["validity"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async securityAdvisoriesListOrgRepositoryAdvisories(
    p: {
      org: string
      direction?: "asc" | "desc"
      sort?: "created" | "updated" | "published"
      before?: string
      after?: string
      perPage?: number
      state?: "triage" | "draft" | "published" | "closed"
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_repository_advisory[]>
      | Res<400, t_scim_error>
      | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/orgs/${p["org"]}/security-advisories`
    const query = this._query({
      direction: p["direction"],
      sort: p["sort"],
      before: p["before"],
      after: p["after"],
      per_page: p["perPage"],
      state: p["state"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async orgsListSecurityManagerTeams(
    p: {
      org: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_team_simple[]>>> {
    const url = this.basePath + `/orgs/${p["org"]}/security-managers`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async orgsAddSecurityManagerTeam(
    p: {
      org: string
      teamSlug: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void> | Res<409, void>>> {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/security-managers/teams/${p["teamSlug"]}`

    return this._fetch(url, {method: "PUT", ...(opts ?? {})}, timeout)
  }

  async orgsRemoveSecurityManagerTeam(
    p: {
      org: string
      teamSlug: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/security-managers/teams/${p["teamSlug"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async billingGetGithubActionsBillingOrg(
    p: {
      org: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_actions_billing_usage>>> {
    const url = this.basePath + `/orgs/${p["org"]}/settings/billing/actions`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async billingGetGithubPackagesBillingOrg(
    p: {
      org: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_packages_billing_usage>>> {
    const url = this.basePath + `/orgs/${p["org"]}/settings/billing/packages`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async billingGetSharedStorageBillingOrg(
    p: {
      org: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_combined_billing_usage>>> {
    const url =
      this.basePath + `/orgs/${p["org"]}/settings/billing/shared-storage`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async teamsList(
    p: {
      org: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_team[]> | Res<403, t_basic_error>>> {
    const url = this.basePath + `/orgs/${p["org"]}/teams`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async teamsCreate(
    p: {
      org: string
      requestBody: t_teamsCreateJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_team_full>
      | Res<403, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/orgs/${p["org"]}/teams`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async teamsGetByName(
    p: {
      org: string
      teamSlug: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_team_full> | Res<404, t_basic_error>>
  > {
    const url = this.basePath + `/orgs/${p["org"]}/teams/${p["teamSlug"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async teamsUpdateInOrg(
    p: {
      org: string
      teamSlug: string
      requestBody?: t_teamsUpdateInOrgJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_team_full>
      | Res<201, t_team_full>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/orgs/${p["org"]}/teams/${p["teamSlug"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PATCH", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async teamsDeleteInOrg(
    p: {
      org: string
      teamSlug: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url = this.basePath + `/orgs/${p["org"]}/teams/${p["teamSlug"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async teamsListDiscussionsInOrg(
    p: {
      org: string
      teamSlug: string
      direction?: "asc" | "desc"
      perPage?: number
      page?: number
      pinned?: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_team_discussion[]>>> {
    const url =
      this.basePath + `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions`
    const query = this._query({
      direction: p["direction"],
      per_page: p["perPage"],
      page: p["page"],
      pinned: p["pinned"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async teamsCreateDiscussionInOrg(
    p: {
      org: string
      teamSlug: string
      requestBody: t_teamsCreateDiscussionInOrgJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<201, t_team_discussion>>> {
    const url =
      this.basePath + `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async teamsGetDiscussionInOrg(
    p: {
      org: string
      teamSlug: string
      discussionNumber: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_team_discussion>>> {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions/${p["discussionNumber"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async teamsUpdateDiscussionInOrg(
    p: {
      org: string
      teamSlug: string
      discussionNumber: number
      requestBody?: t_teamsUpdateDiscussionInOrgJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_team_discussion>>> {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions/${p["discussionNumber"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PATCH", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async teamsDeleteDiscussionInOrg(
    p: {
      org: string
      teamSlug: string
      discussionNumber: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions/${p["discussionNumber"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async teamsListDiscussionCommentsInOrg(
    p: {
      org: string
      teamSlug: string
      discussionNumber: number
      direction?: "asc" | "desc"
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_team_discussion_comment[]>>> {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions/${p["discussionNumber"]}/comments`
    const query = this._query({
      direction: p["direction"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async teamsCreateDiscussionCommentInOrg(
    p: {
      org: string
      teamSlug: string
      discussionNumber: number
      requestBody: t_teamsCreateDiscussionCommentInOrgJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<201, t_team_discussion_comment>>> {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions/${p["discussionNumber"]}/comments`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async teamsGetDiscussionCommentInOrg(
    p: {
      org: string
      teamSlug: string
      discussionNumber: number
      commentNumber: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_team_discussion_comment>>> {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions/${p["discussionNumber"]}/comments/${p["commentNumber"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async teamsUpdateDiscussionCommentInOrg(
    p: {
      org: string
      teamSlug: string
      discussionNumber: number
      commentNumber: number
      requestBody: t_teamsUpdateDiscussionCommentInOrgJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_team_discussion_comment>>> {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions/${p["discussionNumber"]}/comments/${p["commentNumber"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PATCH", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async teamsDeleteDiscussionCommentInOrg(
    p: {
      org: string
      teamSlug: string
      discussionNumber: number
      commentNumber: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions/${p["discussionNumber"]}/comments/${p["commentNumber"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async reactionsListForTeamDiscussionCommentInOrg(
    p: {
      org: string
      teamSlug: string
      discussionNumber: number
      commentNumber: number
      content?:
        | "+1"
        | "-1"
        | "laugh"
        | "confused"
        | "heart"
        | "hooray"
        | "rocket"
        | "eyes"
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_reaction[]>>> {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions/${p["discussionNumber"]}/comments/${p["commentNumber"]}/reactions`
    const query = this._query({
      content: p["content"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reactionsCreateForTeamDiscussionCommentInOrg(
    p: {
      org: string
      teamSlug: string
      discussionNumber: number
      commentNumber: number
      requestBody: t_reactionsCreateForTeamDiscussionCommentInOrgJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_reaction> | Res<201, t_reaction>>> {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions/${p["discussionNumber"]}/comments/${p["commentNumber"]}/reactions`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reactionsDeleteForTeamDiscussionComment(
    p: {
      org: string
      teamSlug: string
      discussionNumber: number
      commentNumber: number
      reactionId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions/${p["discussionNumber"]}/comments/${p["commentNumber"]}/reactions/${p["reactionId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async reactionsListForTeamDiscussionInOrg(
    p: {
      org: string
      teamSlug: string
      discussionNumber: number
      content?:
        | "+1"
        | "-1"
        | "laugh"
        | "confused"
        | "heart"
        | "hooray"
        | "rocket"
        | "eyes"
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_reaction[]>>> {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions/${p["discussionNumber"]}/reactions`
    const query = this._query({
      content: p["content"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reactionsCreateForTeamDiscussionInOrg(
    p: {
      org: string
      teamSlug: string
      discussionNumber: number
      requestBody: t_reactionsCreateForTeamDiscussionInOrgJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_reaction> | Res<201, t_reaction>>> {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions/${p["discussionNumber"]}/reactions`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reactionsDeleteForTeamDiscussion(
    p: {
      org: string
      teamSlug: string
      discussionNumber: number
      reactionId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/teams/${p["teamSlug"]}/discussions/${p["discussionNumber"]}/reactions/${p["reactionId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async teamsListPendingInvitationsInOrg(
    p: {
      org: string
      teamSlug: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_organization_invitation[]>>> {
    const url =
      this.basePath + `/orgs/${p["org"]}/teams/${p["teamSlug"]}/invitations`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async teamsListMembersInOrg(
    p: {
      org: string
      teamSlug: string
      role?: "member" | "maintainer" | "all"
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_simple_user[]>>> {
    const url =
      this.basePath + `/orgs/${p["org"]}/teams/${p["teamSlug"]}/members`
    const query = this._query({
      role: p["role"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async teamsGetMembershipForUserInOrg(
    p: {
      org: string
      teamSlug: string
      username: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_team_membership> | Res<404, void>>> {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/teams/${p["teamSlug"]}/memberships/${p["username"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async teamsAddOrUpdateMembershipForUserInOrg(
    p: {
      org: string
      teamSlug: string
      username: string
      requestBody?: t_teamsAddOrUpdateMembershipForUserInOrgJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_team_membership> | Res<403, void> | Res<422, void>
    >
  > {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/teams/${p["teamSlug"]}/memberships/${p["username"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async teamsRemoveMembershipForUserInOrg(
    p: {
      org: string
      teamSlug: string
      username: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void> | Res<403, void>>> {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/teams/${p["teamSlug"]}/memberships/${p["username"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async teamsListProjectsInOrg(
    p: {
      org: string
      teamSlug: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_team_project[]>>> {
    const url =
      this.basePath + `/orgs/${p["org"]}/teams/${p["teamSlug"]}/projects`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async teamsCheckPermissionsForProjectInOrg(
    p: {
      org: string
      teamSlug: string
      projectId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_team_project> | Res<404, void>>> {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/teams/${p["teamSlug"]}/projects/${p["projectId"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async teamsAddOrUpdateProjectPermissionsInOrg(
    p: {
      org: string
      teamSlug: string
      projectId: number
      requestBody?: t_teamsAddOrUpdateProjectPermissionsInOrgJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<403, t_teamsAddOrUpdateProjectPermissionsInOrgJson403Response>
    >
  > {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/teams/${p["teamSlug"]}/projects/${p["projectId"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async teamsRemoveProjectInOrg(
    p: {
      org: string
      teamSlug: string
      projectId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/teams/${p["teamSlug"]}/projects/${p["projectId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async teamsListReposInOrg(
    p: {
      org: string
      teamSlug: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_minimal_repository[]>>> {
    const url = this.basePath + `/orgs/${p["org"]}/teams/${p["teamSlug"]}/repos`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async teamsCheckPermissionsForRepoInOrg(
    p: {
      org: string
      teamSlug: string
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_team_repository> | Res<204, void> | Res<404, void>
    >
  > {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/teams/${p["teamSlug"]}/repos/${p["owner"]}/${p["repo"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async teamsAddOrUpdateRepoPermissionsInOrg(
    p: {
      org: string
      teamSlug: string
      owner: string
      repo: string
      requestBody?: t_teamsAddOrUpdateRepoPermissionsInOrgJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/teams/${p["teamSlug"]}/repos/${p["owner"]}/${p["repo"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async teamsRemoveRepoInOrg(
    p: {
      org: string
      teamSlug: string
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/teams/${p["teamSlug"]}/repos/${p["owner"]}/${p["repo"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async teamsListChildInOrg(
    p: {
      org: string
      teamSlug: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_team[]>>> {
    const url = this.basePath + `/orgs/${p["org"]}/teams/${p["teamSlug"]}/teams`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async orgsEnableOrDisableSecurityProductOnAllOrgRepos(
    p: {
      org: string
      securityProduct:
        | "dependency_graph"
        | "dependabot_alerts"
        | "dependabot_security_updates"
        | "advanced_security"
        | "code_scanning_default_setup"
        | "secret_scanning"
        | "secret_scanning_push_protection"
      enablement: "enable_all" | "disable_all"
      requestBody?: t_orgsEnableOrDisableSecurityProductOnAllOrgReposJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void> | Res<422, void>>> {
    const url =
      this.basePath +
      `/orgs/${p["org"]}/${p["securityProduct"]}/${p["enablement"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async projectsGetCard(
    p: {
      cardId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_project_card>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/projects/columns/cards/${p["cardId"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async projectsUpdateCard(
    p: {
      cardId: number
      requestBody?: t_projectsUpdateCardJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_project_card>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error_simple>
    >
  > {
    const url = this.basePath + `/projects/columns/cards/${p["cardId"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PATCH", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async projectsDeleteCard(
    p: {
      cardId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_projectsDeleteCardJson403Response>
      | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/projects/columns/cards/${p["cardId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async projectsMoveCard(
    p: {
      cardId: number
      requestBody: t_projectsMoveCardJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_projectsMoveCardJson201Response>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_projectsMoveCardJson403Response>
      | Res<422, t_validation_error>
      | Res<503, t_projectsMoveCardJson503Response>
    >
  > {
    const url = this.basePath + `/projects/columns/cards/${p["cardId"]}/moves`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async projectsGetColumn(
    p: {
      columnId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_project_column>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/projects/columns/${p["columnId"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async projectsUpdateColumn(
    p: {
      columnId: number
      requestBody: t_projectsUpdateColumnJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_project_column>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
    >
  > {
    const url = this.basePath + `/projects/columns/${p["columnId"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PATCH", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async projectsDeleteColumn(
    p: {
      columnId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
    >
  > {
    const url = this.basePath + `/projects/columns/${p["columnId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async projectsListCards(
    p: {
      columnId: number
      archivedState?: "all" | "archived" | "not_archived"
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_project_card[]>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
    >
  > {
    const url = this.basePath + `/projects/columns/${p["columnId"]}/cards`
    const query = this._query({
      archived_state: p["archivedState"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async projectsCreateCard(
    p: {
      columnId: number
      requestBody: t_projectsCreateCardJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_project_card>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<422, t_projectsCreateCardJson422Response>
      | Res<503, t_projectsCreateCardJson503Response>
    >
  > {
    const url = this.basePath + `/projects/columns/${p["columnId"]}/cards`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async projectsMoveColumn(
    p: {
      columnId: number
      requestBody: t_projectsMoveColumnJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_projectsMoveColumnJson201Response>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<422, t_validation_error_simple>
    >
  > {
    const url = this.basePath + `/projects/columns/${p["columnId"]}/moves`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async projectsGet(
    p: {
      projectId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_project>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
    >
  > {
    const url = this.basePath + `/projects/${p["projectId"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async projectsUpdate(
    p: {
      projectId: number
      requestBody?: t_projectsUpdateJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_project>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_projectsUpdateJson403Response>
      | Res<404, void>
      | Res<410, t_basic_error>
      | Res<422, t_validation_error_simple>
    >
  > {
    const url = this.basePath + `/projects/${p["projectId"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PATCH", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async projectsDelete(
    p: {
      projectId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_projectsDeleteJson403Response>
      | Res<404, t_basic_error>
      | Res<410, t_basic_error>
    >
  > {
    const url = this.basePath + `/projects/${p["projectId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async projectsListCollaborators(
    p: {
      projectId: number
      affiliation?: "outside" | "direct" | "all"
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_simple_user[]>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/projects/${p["projectId"]}/collaborators`
    const query = this._query({
      affiliation: p["affiliation"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async projectsAddCollaborator(
    p: {
      projectId: number
      username: string
      requestBody?: t_projectsAddCollaboratorJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath +
      `/projects/${p["projectId"]}/collaborators/${p["username"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async projectsRemoveCollaborator(
    p: {
      projectId: number
      username: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath +
      `/projects/${p["projectId"]}/collaborators/${p["username"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async projectsGetPermissionForUser(
    p: {
      projectId: number
      username: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_project_collaborator_permission>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath +
      `/projects/${p["projectId"]}/collaborators/${p["username"]}/permission`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async projectsListColumns(
    p: {
      projectId: number
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_project_column[]>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
    >
  > {
    const url = this.basePath + `/projects/${p["projectId"]}/columns`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async projectsCreateColumn(
    p: {
      projectId: number
      requestBody: t_projectsCreateColumnJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_project_column>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<422, t_validation_error_simple>
    >
  > {
    const url = this.basePath + `/projects/${p["projectId"]}/columns`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async rateLimitGet(
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_rate_limit_overview> | Res<304, void> | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/rate_limit`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposGet(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_full_repository>
      | Res<301, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposUpdate(
    p: {
      owner: string
      repo: string
      requestBody?: t_reposUpdateJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_full_repository>
      | Res<307, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PATCH", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reposDelete(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<307, t_basic_error>
      | Res<403, t_reposDeleteJson403Response>
      | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async actionsListArtifactsForRepo(
    p: {
      owner: string
      repo: string
      perPage?: number
      page?: number
      name?: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_actionsListArtifactsForRepoJson200Response>>
  > {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/actions/artifacts`
    const query = this._query({
      per_page: p["perPage"],
      page: p["page"],
      name: p["name"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsGetArtifact(
    p: {
      owner: string
      repo: string
      artifactId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_artifact>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/artifacts/${p["artifactId"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsDeleteArtifact(
    p: {
      owner: string
      repo: string
      artifactId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/artifacts/${p["artifactId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async actionsDownloadArtifact(
    p: {
      owner: string
      repo: string
      artifactId: number
      archiveFormat: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<302, void> | Res<410, t_basic_error>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/artifacts/${p["artifactId"]}/${p["archiveFormat"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsGetActionsCacheUsage(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_actions_cache_usage_by_repository>>
  > {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/actions/cache/usage`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsGetActionsCacheList(
    p: {
      owner: string
      repo: string
      perPage?: number
      page?: number
      ref?: string
      key?: string
      sort?: "created_at" | "last_accessed_at" | "size_in_bytes"
      direction?: "asc" | "desc"
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_actions_cache_list>>> {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/actions/caches`
    const query = this._query({
      per_page: p["perPage"],
      page: p["page"],
      ref: p["ref"],
      key: p["key"],
      sort: p["sort"],
      direction: p["direction"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsDeleteActionsCacheByKey(
    p: {
      owner: string
      repo: string
      key: string
      ref?: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_actions_cache_list>>> {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/actions/caches`
    const query = this._query({key: p["key"], ref: p["ref"]})

    return this._fetch(
      url + query,
      {method: "DELETE", ...(opts ?? {})},
      timeout,
    )
  }

  async actionsDeleteActionsCacheById(
    p: {
      owner: string
      repo: string
      cacheId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/caches/${p["cacheId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async actionsGetJobForWorkflowRun(
    p: {
      owner: string
      repo: string
      jobId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_job>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/jobs/${p["jobId"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsDownloadJobLogsForWorkflowRun(
    p: {
      owner: string
      repo: string
      jobId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<302, void>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/jobs/${p["jobId"]}/logs`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsReRunJobForWorkflowRun(
    p: {
      owner: string
      repo: string
      jobId: number
      requestBody?: t_actionsReRunJobForWorkflowRunJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<201, t_empty_object> | Res<403, t_basic_error>>
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/jobs/${p["jobId"]}/rerun`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async actionsGetCustomOidcSubClaimForRepo(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_oidc_custom_sub_repo>
      | Res<400, t_scim_error>
      | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/oidc/customization/sub`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsSetCustomOidcSubClaimForRepo(
    p: {
      owner: string
      repo: string
      requestBody: t_actionsSetCustomOidcSubClaimForRepoJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_empty_object>
      | Res<400, t_scim_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error_simple>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/oidc/customization/sub`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async actionsListRepoOrganizationSecrets(
    p: {
      owner: string
      repo: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_actionsListRepoOrganizationSecretsJson200Response>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/organization-secrets`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsListRepoOrganizationVariables(
    p: {
      owner: string
      repo: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_actionsListRepoOrganizationVariablesJson200Response>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/organization-variables`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsGetGithubActionsPermissionsRepository(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_actions_repository_permissions>>> {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/actions/permissions`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsSetGithubActionsPermissionsRepository(
    p: {
      owner: string
      repo: string
      requestBody: t_actionsSetGithubActionsPermissionsRepositoryJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/actions/permissions`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async actionsGetWorkflowAccessToRepository(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_actions_workflow_access_to_repository>>
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/permissions/access`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsSetWorkflowAccessToRepository(
    p: {
      owner: string
      repo: string
      requestBody: t_actions_workflow_access_to_repository
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/permissions/access`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async actionsGetAllowedActionsRepository(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_selected_actions>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/permissions/selected-actions`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsSetAllowedActionsRepository(
    p: {
      owner: string
      repo: string
      requestBody?: t_selected_actions
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/permissions/selected-actions`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async actionsGetGithubActionsDefaultWorkflowPermissionsRepository(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_actions_get_default_workflow_permissions>>
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/permissions/workflow`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsSetGithubActionsDefaultWorkflowPermissionsRepository(
    p: {
      owner: string
      repo: string
      requestBody: t_actions_set_default_workflow_permissions
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void> | Res<409, void>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/permissions/workflow`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async actionsListSelfHostedRunnersForRepo(
    p: {
      name?: string
      owner: string
      repo: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_actionsListSelfHostedRunnersForRepoJson200Response>
    >
  > {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/actions/runners`
    const query = this._query({
      name: p["name"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsListRunnerApplicationsForRepo(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_runner_application[]>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/runners/downloads`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsGenerateRunnerJitconfigForRepo(
    p: {
      owner: string
      repo: string
      requestBody: t_actionsGenerateRunnerJitconfigForRepoJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_actionsGenerateRunnerJitconfigForRepoJson201Response>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error_simple>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/runners/generate-jitconfig`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async actionsCreateRegistrationTokenForRepo(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<201, t_authentication_token>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/runners/registration-token`

    return this._fetch(url, {method: "POST", ...(opts ?? {})}, timeout)
  }

  async actionsCreateRemoveTokenForRepo(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<201, t_authentication_token>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/runners/remove-token`

    return this._fetch(url, {method: "POST", ...(opts ?? {})}, timeout)
  }

  async actionsGetSelfHostedRunnerForRepo(
    p: {
      owner: string
      repo: string
      runnerId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_runner>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/runners/${p["runnerId"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsDeleteSelfHostedRunnerFromRepo(
    p: {
      owner: string
      repo: string
      runnerId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/runners/${p["runnerId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async actionsListLabelsForSelfHostedRunnerForRepo(
    p: {
      owner: string
      repo: string
      runnerId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_actionsListLabelsForSelfHostedRunnerForRepoJson200Response>
      | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/runners/${p["runnerId"]}/labels`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsAddCustomLabelsToSelfHostedRunnerForRepo(
    p: {
      owner: string
      repo: string
      runnerId: number
      requestBody: t_actionsAddCustomLabelsToSelfHostedRunnerForRepoJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          t_actionsAddCustomLabelsToSelfHostedRunnerForRepoJson200Response
        >
      | Res<404, t_basic_error>
      | Res<422, t_validation_error_simple>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/runners/${p["runnerId"]}/labels`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async actionsSetCustomLabelsForSelfHostedRunnerForRepo(
    p: {
      owner: string
      repo: string
      runnerId: number
      requestBody: t_actionsSetCustomLabelsForSelfHostedRunnerForRepoJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          t_actionsSetCustomLabelsForSelfHostedRunnerForRepoJson200Response
        >
      | Res<404, t_basic_error>
      | Res<422, t_validation_error_simple>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/runners/${p["runnerId"]}/labels`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo(
    p: {
      owner: string
      repo: string
      runnerId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          t_actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoJson200Response
        >
      | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/runners/${p["runnerId"]}/labels`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async actionsRemoveCustomLabelFromSelfHostedRunnerForRepo(
    p: {
      owner: string
      repo: string
      runnerId: number
      name: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          t_actionsRemoveCustomLabelFromSelfHostedRunnerForRepoJson200Response
        >
      | Res<404, t_basic_error>
      | Res<422, t_validation_error_simple>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/runners/${p["runnerId"]}/labels/${p["name"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async actionsListWorkflowRunsForRepo(
    p: {
      owner: string
      repo: string
      actor?: string
      branch?: string
      event?: string
      status?:
        | "completed"
        | "action_required"
        | "cancelled"
        | "failure"
        | "neutral"
        | "skipped"
        | "stale"
        | "success"
        | "timed_out"
        | "in_progress"
        | "queued"
        | "requested"
        | "waiting"
        | "pending"
      perPage?: number
      page?: number
      created?: string
      excludePullRequests?: boolean
      checkSuiteId?: number
      headSha?: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_actionsListWorkflowRunsForRepoJson200Response>
    >
  > {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/actions/runs`
    const query = this._query({
      actor: p["actor"],
      branch: p["branch"],
      event: p["event"],
      status: p["status"],
      per_page: p["perPage"],
      page: p["page"],
      created: p["created"],
      exclude_pull_requests: p["excludePullRequests"],
      check_suite_id: p["checkSuiteId"],
      head_sha: p["headSha"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsGetWorkflowRun(
    p: {
      owner: string
      repo: string
      runId: number
      excludePullRequests?: boolean
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_workflow_run>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${p["runId"]}`
    const query = this._query({
      exclude_pull_requests: p["excludePullRequests"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsDeleteWorkflowRun(
    p: {
      owner: string
      repo: string
      runId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${p["runId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async actionsGetReviewsForRun(
    p: {
      owner: string
      repo: string
      runId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_environment_approvals[]>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${p["runId"]}/approvals`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsApproveWorkflowRun(
    p: {
      owner: string
      repo: string
      runId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_empty_object>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${p["runId"]}/approve`

    return this._fetch(url, {method: "POST", ...(opts ?? {})}, timeout)
  }

  async actionsListWorkflowRunArtifacts(
    p: {
      owner: string
      repo: string
      runId: number
      perPage?: number
      page?: number
      name?: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_actionsListWorkflowRunArtifactsJson200Response>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${p["runId"]}/artifacts`
    const query = this._query({
      per_page: p["perPage"],
      page: p["page"],
      name: p["name"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsGetWorkflowRunAttempt(
    p: {
      owner: string
      repo: string
      runId: number
      attemptNumber: number
      excludePullRequests?: boolean
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_workflow_run>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${p["runId"]}/attempts/${p["attemptNumber"]}`
    const query = this._query({
      exclude_pull_requests: p["excludePullRequests"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsListJobsForWorkflowRunAttempt(
    p: {
      owner: string
      repo: string
      runId: number
      attemptNumber: number
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_actionsListJobsForWorkflowRunAttemptJson200Response>
      | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${p["runId"]}/attempts/${p["attemptNumber"]}/jobs`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsDownloadWorkflowRunAttemptLogs(
    p: {
      owner: string
      repo: string
      runId: number
      attemptNumber: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<302, void>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${p["runId"]}/attempts/${p["attemptNumber"]}/logs`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsCancelWorkflowRun(
    p: {
      owner: string
      repo: string
      runId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<202, t_empty_object> | Res<409, t_basic_error>>
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${p["runId"]}/cancel`

    return this._fetch(url, {method: "POST", ...(opts ?? {})}, timeout)
  }

  async actionsReviewCustomGatesForRun(
    p: {
      owner: string
      repo: string
      runId: number
      requestBody: t_actionsReviewCustomGatesForRunJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${p["runId"]}/deployment_protection_rule`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async actionsForceCancelWorkflowRun(
    p: {
      owner: string
      repo: string
      runId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<202, t_empty_object> | Res<409, t_basic_error>>
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${p["runId"]}/force-cancel`

    return this._fetch(url, {method: "POST", ...(opts ?? {})}, timeout)
  }

  async actionsListJobsForWorkflowRun(
    p: {
      owner: string
      repo: string
      runId: number
      filter?: "latest" | "all"
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_actionsListJobsForWorkflowRunJson200Response>>
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${p["runId"]}/jobs`
    const query = this._query({
      filter: p["filter"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsDownloadWorkflowRunLogs(
    p: {
      owner: string
      repo: string
      runId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<302, void>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${p["runId"]}/logs`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsDeleteWorkflowRunLogs(
    p: {
      owner: string
      repo: string
      runId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<204, void> | Res<403, t_basic_error> | Res<500, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${p["runId"]}/logs`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async actionsGetPendingDeploymentsForRun(
    p: {
      owner: string
      repo: string
      runId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_pending_deployment[]>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${p["runId"]}/pending_deployments`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsReviewPendingDeploymentsForRun(
    p: {
      owner: string
      repo: string
      runId: number
      requestBody: t_actionsReviewPendingDeploymentsForRunJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_deployment[]>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${p["runId"]}/pending_deployments`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async actionsReRunWorkflow(
    p: {
      owner: string
      repo: string
      runId: number
      requestBody?: t_actionsReRunWorkflowJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<201, t_empty_object>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${p["runId"]}/rerun`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async actionsReRunWorkflowFailedJobs(
    p: {
      owner: string
      repo: string
      runId: number
      requestBody?: t_actionsReRunWorkflowFailedJobsJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<201, t_empty_object>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${p["runId"]}/rerun-failed-jobs`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async actionsGetWorkflowRunUsage(
    p: {
      owner: string
      repo: string
      runId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_workflow_run_usage>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/runs/${p["runId"]}/timing`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsListRepoSecrets(
    p: {
      owner: string
      repo: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_actionsListRepoSecretsJson200Response>>
  > {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/actions/secrets`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsGetRepoPublicKey(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_actions_public_key>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/secrets/public-key`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsGetRepoSecret(
    p: {
      owner: string
      repo: string
      secretName: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_actions_secret>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/secrets/${p["secretName"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsCreateOrUpdateRepoSecret(
    p: {
      owner: string
      repo: string
      secretName: string
      requestBody: t_actionsCreateOrUpdateRepoSecretJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<201, t_empty_object> | Res<204, void>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/secrets/${p["secretName"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async actionsDeleteRepoSecret(
    p: {
      owner: string
      repo: string
      secretName: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/secrets/${p["secretName"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async actionsListRepoVariables(
    p: {
      owner: string
      repo: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_actionsListRepoVariablesJson200Response>>
  > {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/actions/variables`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsCreateRepoVariable(
    p: {
      owner: string
      repo: string
      requestBody: t_actionsCreateRepoVariableJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<201, t_empty_object>>> {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/actions/variables`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async actionsGetRepoVariable(
    p: {
      owner: string
      repo: string
      name: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_actions_variable>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/variables/${p["name"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsUpdateRepoVariable(
    p: {
      owner: string
      repo: string
      name: string
      requestBody: t_actionsUpdateRepoVariableJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/variables/${p["name"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PATCH", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async actionsDeleteRepoVariable(
    p: {
      owner: string
      repo: string
      name: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/variables/${p["name"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async actionsListRepoWorkflows(
    p: {
      owner: string
      repo: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_actionsListRepoWorkflowsJson200Response>>
  > {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/actions/workflows`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsGetWorkflow(
    p: {
      owner: string
      repo: string
      workflowId: number | string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_workflow>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/workflows/${p["workflowId"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsDisableWorkflow(
    p: {
      owner: string
      repo: string
      workflowId: number | string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/workflows/${p["workflowId"]}/disable`

    return this._fetch(url, {method: "PUT", ...(opts ?? {})}, timeout)
  }

  async actionsCreateWorkflowDispatch(
    p: {
      owner: string
      repo: string
      workflowId: number | string
      requestBody: t_actionsCreateWorkflowDispatchJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/workflows/${p["workflowId"]}/dispatches`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async actionsEnableWorkflow(
    p: {
      owner: string
      repo: string
      workflowId: number | string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/workflows/${p["workflowId"]}/enable`

    return this._fetch(url, {method: "PUT", ...(opts ?? {})}, timeout)
  }

  async actionsListWorkflowRuns(
    p: {
      owner: string
      repo: string
      workflowId: number | string
      actor?: string
      branch?: string
      event?: string
      status?:
        | "completed"
        | "action_required"
        | "cancelled"
        | "failure"
        | "neutral"
        | "skipped"
        | "stale"
        | "success"
        | "timed_out"
        | "in_progress"
        | "queued"
        | "requested"
        | "waiting"
        | "pending"
      perPage?: number
      page?: number
      created?: string
      excludePullRequests?: boolean
      checkSuiteId?: number
      headSha?: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_actionsListWorkflowRunsJson200Response>>
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/workflows/${p["workflowId"]}/runs`
    const query = this._query({
      actor: p["actor"],
      branch: p["branch"],
      event: p["event"],
      status: p["status"],
      per_page: p["perPage"],
      page: p["page"],
      created: p["created"],
      exclude_pull_requests: p["excludePullRequests"],
      check_suite_id: p["checkSuiteId"],
      head_sha: p["headSha"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsGetWorkflowUsage(
    p: {
      owner: string
      repo: string
      workflowId: number | string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_workflow_usage>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/actions/workflows/${p["workflowId"]}/timing`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposListActivities(
    p: {
      owner: string
      repo: string
      direction?: "asc" | "desc"
      perPage?: number
      before?: string
      after?: string
      ref?: string
      actor?: string
      timePeriod?: "day" | "week" | "month" | "quarter" | "year"
      activityType?:
        | "push"
        | "force_push"
        | "branch_creation"
        | "branch_deletion"
        | "pr_merge"
        | "merge_queue_merge"
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_activity[]> | Res<422, t_validation_error_simple>
    >
  > {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/activity`
    const query = this._query({
      direction: p["direction"],
      per_page: p["perPage"],
      before: p["before"],
      after: p["after"],
      ref: p["ref"],
      actor: p["actor"],
      time_period: p["timePeriod"],
      activity_type: p["activityType"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async issuesListAssignees(
    p: {
      owner: string
      repo: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_simple_user[]> | Res<404, t_basic_error>>
  > {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/assignees`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async issuesCheckUserCanBeAssigned(
    p: {
      owner: string
      repo: string
      assignee: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void> | Res<404, t_basic_error>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/assignees/${p["assignee"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposListAutolinks(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_autolink[]>>> {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/autolinks`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposCreateAutolink(
    p: {
      owner: string
      repo: string
      requestBody: t_reposCreateAutolinkJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<201, t_autolink> | Res<422, t_validation_error>>
  > {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/autolinks`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reposGetAutolink(
    p: {
      owner: string
      repo: string
      autolinkId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_autolink> | Res<404, t_basic_error>>
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/autolinks/${p["autolinkId"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposDeleteAutolink(
    p: {
      owner: string
      repo: string
      autolinkId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void> | Res<404, t_basic_error>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/autolinks/${p["autolinkId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async reposCheckAutomatedSecurityFixes(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_check_automated_security_fixes> | Res<404, void>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/automated-security-fixes`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposEnableAutomatedSecurityFixes(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/automated-security-fixes`

    return this._fetch(url, {method: "PUT", ...(opts ?? {})}, timeout)
  }

  async reposDisableAutomatedSecurityFixes(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/automated-security-fixes`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async reposListBranches(
    p: {
      owner: string
      repo: string
      protected?: boolean
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_short_branch[]> | Res<404, t_basic_error>>
  > {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/branches`
    const query = this._query({
      protected: p["protected"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposGetBranch(
    p: {
      owner: string
      repo: string
      branch: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_branch_with_protection>
      | Res<301, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposGetBranchProtection(
    p: {
      owner: string
      repo: string
      branch: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_branch_protection> | Res<404, t_basic_error>>
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposUpdateBranchProtection(
    p: {
      owner: string
      repo: string
      branch: string
      requestBody: t_reposUpdateBranchProtectionJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_protected_branch>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error_simple>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reposDeleteBranchProtection(
    p: {
      owner: string
      repo: string
      branch: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void> | Res<403, t_basic_error>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async reposGetAdminBranchProtection(
    p: {
      owner: string
      repo: string
      branch: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_protected_branch_admin_enforced>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/enforce_admins`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposSetAdminBranchProtection(
    p: {
      owner: string
      repo: string
      branch: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_protected_branch_admin_enforced>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/enforce_admins`

    return this._fetch(url, {method: "POST", ...(opts ?? {})}, timeout)
  }

  async reposDeleteAdminBranchProtection(
    p: {
      owner: string
      repo: string
      branch: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void> | Res<404, t_basic_error>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/enforce_admins`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async reposGetPullRequestReviewProtection(
    p: {
      owner: string
      repo: string
      branch: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_protected_branch_pull_request_review>>
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/required_pull_request_reviews`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposUpdatePullRequestReviewProtection(
    p: {
      owner: string
      repo: string
      branch: string
      requestBody?: t_reposUpdatePullRequestReviewProtectionJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_protected_branch_pull_request_review>
      | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/required_pull_request_reviews`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PATCH", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reposDeletePullRequestReviewProtection(
    p: {
      owner: string
      repo: string
      branch: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void> | Res<404, t_basic_error>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/required_pull_request_reviews`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async reposGetCommitSignatureProtection(
    p: {
      owner: string
      repo: string
      branch: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_protected_branch_admin_enforced> | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/required_signatures`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposCreateCommitSignatureProtection(
    p: {
      owner: string
      repo: string
      branch: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_protected_branch_admin_enforced> | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/required_signatures`

    return this._fetch(url, {method: "POST", ...(opts ?? {})}, timeout)
  }

  async reposDeleteCommitSignatureProtection(
    p: {
      owner: string
      repo: string
      branch: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void> | Res<404, t_basic_error>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/required_signatures`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async reposGetStatusChecksProtection(
    p: {
      owner: string
      repo: string
      branch: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_status_check_policy> | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/required_status_checks`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposUpdateStatusCheckProtection(
    p: {
      owner: string
      repo: string
      branch: string
      requestBody?: t_reposUpdateStatusCheckProtectionJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_status_check_policy>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/required_status_checks`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PATCH", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reposRemoveStatusCheckProtection(
    p: {
      owner: string
      repo: string
      branch: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/required_status_checks`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async reposGetAllStatusCheckContexts(
    p: {
      owner: string
      repo: string
      branch: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, string[]> | Res<404, t_basic_error>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/required_status_checks/contexts`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposAddStatusCheckContexts(
    p: {
      owner: string
      repo: string
      branch: string
      requestBody?: t_reposAddStatusCheckContextsJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, string[]>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/required_status_checks/contexts`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reposSetStatusCheckContexts(
    p: {
      owner: string
      repo: string
      branch: string
      requestBody?: t_reposSetStatusCheckContextsJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, string[]>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/required_status_checks/contexts`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reposRemoveStatusCheckContexts(
    p: {
      owner: string
      repo: string
      branch: string
      requestBody: t_reposRemoveStatusCheckContextsJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, string[]>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/required_status_checks/contexts`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "DELETE", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reposGetAccessRestrictions(
    p: {
      owner: string
      repo: string
      branch: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_branch_restriction_policy> | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/restrictions`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposDeleteAccessRestrictions(
    p: {
      owner: string
      repo: string
      branch: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/restrictions`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async reposGetAppsWithAccessToProtectedBranch(
    p: {
      owner: string
      repo: string
      branch: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_integration[]> | Res<404, t_basic_error>>
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/restrictions/apps`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposAddAppAccessRestrictions(
    p: {
      owner: string
      repo: string
      branch: string
      requestBody?: t_reposAddAppAccessRestrictionsJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_integration[]> | Res<422, t_validation_error>>
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/restrictions/apps`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reposSetAppAccessRestrictions(
    p: {
      owner: string
      repo: string
      branch: string
      requestBody?: t_reposSetAppAccessRestrictionsJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_integration[]> | Res<422, t_validation_error>>
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/restrictions/apps`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reposRemoveAppAccessRestrictions(
    p: {
      owner: string
      repo: string
      branch: string
      requestBody: t_reposRemoveAppAccessRestrictionsJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_integration[]> | Res<422, t_validation_error>>
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/restrictions/apps`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "DELETE", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reposGetTeamsWithAccessToProtectedBranch(
    p: {
      owner: string
      repo: string
      branch: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_team[]> | Res<404, t_basic_error>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/restrictions/teams`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposAddTeamAccessRestrictions(
    p: {
      owner: string
      repo: string
      branch: string
      requestBody?: t_reposAddTeamAccessRestrictionsJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_team[]> | Res<422, t_validation_error>>
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/restrictions/teams`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reposSetTeamAccessRestrictions(
    p: {
      owner: string
      repo: string
      branch: string
      requestBody?: t_reposSetTeamAccessRestrictionsJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_team[]> | Res<422, t_validation_error>>
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/restrictions/teams`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reposRemoveTeamAccessRestrictions(
    p: {
      owner: string
      repo: string
      branch: string
      requestBody: t_reposRemoveTeamAccessRestrictionsJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_team[]> | Res<422, t_validation_error>>
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/restrictions/teams`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "DELETE", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reposGetUsersWithAccessToProtectedBranch(
    p: {
      owner: string
      repo: string
      branch: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_simple_user[]> | Res<404, t_basic_error>>
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/restrictions/users`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposAddUserAccessRestrictions(
    p: {
      owner: string
      repo: string
      branch: string
      requestBody?: t_reposAddUserAccessRestrictionsJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_simple_user[]> | Res<422, t_validation_error>>
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/restrictions/users`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reposSetUserAccessRestrictions(
    p: {
      owner: string
      repo: string
      branch: string
      requestBody?: t_reposSetUserAccessRestrictionsJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_simple_user[]> | Res<422, t_validation_error>>
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/restrictions/users`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reposRemoveUserAccessRestrictions(
    p: {
      owner: string
      repo: string
      branch: string
      requestBody: t_reposRemoveUserAccessRestrictionsJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_simple_user[]> | Res<422, t_validation_error>>
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/protection/restrictions/users`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "DELETE", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reposRenameBranch(
    p: {
      owner: string
      repo: string
      branch: string
      requestBody: t_reposRenameBranchJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_branch_with_protection>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/branches/${p["branch"]}/rename`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async checksCreate(
    p: {
      owner: string
      repo: string
      requestBody: t_checksCreateJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<201, t_check_run>>> {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/check-runs`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async checksGet(
    p: {
      owner: string
      repo: string
      checkRunId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_check_run>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/check-runs/${p["checkRunId"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async checksUpdate(
    p: {
      owner: string
      repo: string
      checkRunId: number
      requestBody: t_checksUpdateJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_check_run>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/check-runs/${p["checkRunId"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PATCH", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async checksListAnnotations(
    p: {
      owner: string
      repo: string
      checkRunId: number
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_check_annotation[]>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/check-runs/${p["checkRunId"]}/annotations`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async checksRerequestRun(
    p: {
      owner: string
      repo: string
      checkRunId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_empty_object>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/check-runs/${p["checkRunId"]}/rerequest`

    return this._fetch(url, {method: "POST", ...(opts ?? {})}, timeout)
  }

  async checksCreateSuite(
    p: {
      owner: string
      repo: string
      requestBody: t_checksCreateSuiteJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_check_suite> | Res<201, t_check_suite>>
  > {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/check-suites`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async checksSetSuitesPreferences(
    p: {
      owner: string
      repo: string
      requestBody: t_checksSetSuitesPreferencesJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_check_suite_preference>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/check-suites/preferences`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PATCH", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async checksGetSuite(
    p: {
      owner: string
      repo: string
      checkSuiteId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_check_suite>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/check-suites/${p["checkSuiteId"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async checksListForSuite(
    p: {
      owner: string
      repo: string
      checkSuiteId: number
      checkName?: string
      status?: "queued" | "in_progress" | "completed"
      filter?: "latest" | "all"
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_checksListForSuiteJson200Response>>
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/check-suites/${p["checkSuiteId"]}/check-runs`
    const query = this._query({
      check_name: p["checkName"],
      status: p["status"],
      filter: p["filter"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async checksRerequestSuite(
    p: {
      owner: string
      repo: string
      checkSuiteId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<201, t_empty_object>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/check-suites/${p["checkSuiteId"]}/rerequest`

    return this._fetch(url, {method: "POST", ...(opts ?? {})}, timeout)
  }

  async codeScanningListAlertsForRepo(
    p: {
      owner: string
      repo: string
      toolName?: t_code_scanning_analysis_tool_name
      toolGuid?: t_code_scanning_analysis_tool_guid
      page?: number
      perPage?: number
      ref?: t_code_scanning_ref
      direction?: "asc" | "desc"
      sort?: "created" | "updated"
      state?: t_code_scanning_alert_state_query
      severity?: t_code_scanning_alert_severity
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_code_scanning_alert_items[]>
      | Res<304, void>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<503, t_codeScanningListAlertsForRepoJson503Response>
    >
  > {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/code-scanning/alerts`
    const query = this._query({
      tool_name: p["toolName"],
      tool_guid: p["toolGuid"],
      page: p["page"],
      per_page: p["perPage"],
      ref: p["ref"],
      direction: p["direction"],
      sort: p["sort"],
      state: p["state"],
      severity: p["severity"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async codeScanningGetAlert(
    p: {
      owner: string
      repo: string
      alertNumber: t_alert_number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_code_scanning_alert>
      | Res<304, void>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<503, t_codeScanningGetAlertJson503Response>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/code-scanning/alerts/${p["alertNumber"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async codeScanningUpdateAlert(
    p: {
      owner: string
      repo: string
      alertNumber: t_alert_number
      requestBody: t_codeScanningUpdateAlertJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_code_scanning_alert>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<503, t_codeScanningUpdateAlertJson503Response>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/code-scanning/alerts/${p["alertNumber"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PATCH", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async codeScanningListAlertInstances(
    p: {
      owner: string
      repo: string
      alertNumber: t_alert_number
      page?: number
      perPage?: number
      ref?: t_code_scanning_ref
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_code_scanning_alert_instance[]>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<503, t_codeScanningListAlertInstancesJson503Response>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/code-scanning/alerts/${p["alertNumber"]}/instances`
    const query = this._query({
      page: p["page"],
      per_page: p["perPage"],
      ref: p["ref"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async codeScanningListRecentAnalyses(
    p: {
      owner: string
      repo: string
      toolName?: t_code_scanning_analysis_tool_name
      toolGuid?: t_code_scanning_analysis_tool_guid
      page?: number
      perPage?: number
      ref?: t_code_scanning_ref
      sarifId?: t_code_scanning_analysis_sarif_id
      direction?: "asc" | "desc"
      sort?: "created"
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_code_scanning_analysis[]>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<503, t_codeScanningListRecentAnalysesJson503Response>
    >
  > {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/code-scanning/analyses`
    const query = this._query({
      tool_name: p["toolName"],
      tool_guid: p["toolGuid"],
      page: p["page"],
      per_page: p["perPage"],
      ref: p["ref"],
      sarif_id: p["sarifId"],
      direction: p["direction"],
      sort: p["sort"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async codeScanningGetAnalysis(
    p: {
      owner: string
      repo: string
      analysisId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_codeScanningGetAnalysisApplicationJsonSarif200Response>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<503, t_codeScanningGetAnalysisJson503Response>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/code-scanning/analyses/${p["analysisId"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async codeScanningDeleteAnalysis(
    p: {
      owner: string
      repo: string
      analysisId: number
      confirmDelete?: string | null
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_code_scanning_analysis_deletion>
      | Res<400, t_scim_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<503, t_codeScanningDeleteAnalysisJson503Response>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/code-scanning/analyses/${p["analysisId"]}`
    const query = this._query({confirm_delete: p["confirmDelete"]})

    return this._fetch(
      url + query,
      {method: "DELETE", ...(opts ?? {})},
      timeout,
    )
  }

  async codeScanningListCodeqlDatabases(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_code_scanning_codeql_database[]>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<503, t_codeScanningListCodeqlDatabasesJson503Response>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/code-scanning/codeql/databases`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async codeScanningGetCodeqlDatabase(
    p: {
      owner: string
      repo: string
      language: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_code_scanning_codeql_database>
      | Res<302, void>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<503, t_codeScanningGetCodeqlDatabaseJson503Response>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/code-scanning/codeql/databases/${p["language"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async codeScanningGetDefaultSetup(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_code_scanning_default_setup>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<503, t_codeScanningGetDefaultSetupJson503Response>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/code-scanning/default-setup`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async codeScanningUpdateDefaultSetup(
    p: {
      owner: string
      repo: string
      requestBody: t_code_scanning_default_setup_update
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_empty_object>
      | Res<202, t_code_scanning_default_setup_update_response>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<409, t_basic_error>
      | Res<503, t_codeScanningUpdateDefaultSetupJson503Response>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/code-scanning/default-setup`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PATCH", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async codeScanningUploadSarif(
    p: {
      owner: string
      repo: string
      requestBody: t_codeScanningUploadSarifJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<202, t_code_scanning_sarifs_receipt>
      | Res<400, void>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<413, void>
      | Res<503, t_codeScanningUploadSarifJson503Response>
    >
  > {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/code-scanning/sarifs`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async codeScanningGetSarif(
    p: {
      owner: string
      repo: string
      sarifId: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_code_scanning_sarifs_status>
      | Res<403, t_basic_error>
      | Res<404, void>
      | Res<503, t_codeScanningGetSarifJson503Response>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/code-scanning/sarifs/${p["sarifId"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposCodeownersErrors(
    p: {
      owner: string
      repo: string
      ref?: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_codeowners_errors> | Res<404, void>>
  > {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/codeowners/errors`
    const query = this._query({ref: p["ref"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async codespacesListInRepositoryForAuthenticatedUser(
    p: {
      perPage?: number
      page?: number
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          t_codespacesListInRepositoryForAuthenticatedUserJson200Response
        >
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<500, t_basic_error>
    >
  > {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/codespaces`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async codespacesCreateWithRepoForAuthenticatedUser(
    p: {
      owner: string
      repo: string
      requestBody: t_codespacesCreateWithRepoForAuthenticatedUserJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_codespace>
      | Res<202, t_codespace>
      | Res<400, t_scim_error>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<503, t_codespacesCreateWithRepoForAuthenticatedUserJson503Response>
    >
  > {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/codespaces`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async codespacesListDevcontainersInRepositoryForAuthenticatedUser(
    p: {
      perPage?: number
      page?: number
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          t_codespacesListDevcontainersInRepositoryForAuthenticatedUserJson200Response
        >
      | Res<400, t_scim_error>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<500, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/codespaces/devcontainers`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async codespacesRepoMachinesForAuthenticatedUser(
    p: {
      owner: string
      repo: string
      location?: string
      clientIp?: string
      ref?: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_codespacesRepoMachinesForAuthenticatedUserJson200Response>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<500, t_basic_error>
    >
  > {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/codespaces/machines`
    const query = this._query({
      location: p["location"],
      client_ip: p["clientIp"],
      ref: p["ref"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async codespacesPreFlightWithRepoForAuthenticatedUser(
    p: {
      owner: string
      repo: string
      ref?: string
      clientIp?: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          t_codespacesPreFlightWithRepoForAuthenticatedUserJson200Response
        >
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/codespaces/new`
    const query = this._query({ref: p["ref"], client_ip: p["clientIp"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async codespacesCheckPermissionsForDevcontainer(
    p: {
      owner: string
      repo: string
      ref: string
      devcontainerPath: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_codespaces_permissions_check_for_devcontainer>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
      | Res<503, t_codespacesCheckPermissionsForDevcontainerJson503Response>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/codespaces/permissions_check`
    const query = this._query({
      ref: p["ref"],
      devcontainer_path: p["devcontainerPath"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async codespacesListRepoSecrets(
    p: {
      owner: string
      repo: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_codespacesListRepoSecretsJson200Response>>
  > {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/codespaces/secrets`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async codespacesGetRepoPublicKey(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_codespaces_public_key>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/codespaces/secrets/public-key`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async codespacesGetRepoSecret(
    p: {
      owner: string
      repo: string
      secretName: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_repo_codespaces_secret>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/codespaces/secrets/${p["secretName"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async codespacesCreateOrUpdateRepoSecret(
    p: {
      owner: string
      repo: string
      secretName: string
      requestBody: t_codespacesCreateOrUpdateRepoSecretJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<201, t_empty_object> | Res<204, void>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/codespaces/secrets/${p["secretName"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async codespacesDeleteRepoSecret(
    p: {
      owner: string
      repo: string
      secretName: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/codespaces/secrets/${p["secretName"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async reposListCollaborators(
    p: {
      owner: string
      repo: string
      affiliation?: "outside" | "direct" | "all"
      permission?: "pull" | "triage" | "push" | "maintain" | "admin"
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_collaborator[]> | Res<404, t_basic_error>>
  > {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/collaborators`
    const query = this._query({
      affiliation: p["affiliation"],
      permission: p["permission"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposCheckCollaborator(
    p: {
      owner: string
      repo: string
      username: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void> | Res<404, void>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/collaborators/${p["username"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposAddCollaborator(
    p: {
      owner: string
      repo: string
      username: string
      requestBody?: t_reposAddCollaboratorJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_repository_invitation>
      | Res<204, void>
      | Res<403, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/collaborators/${p["username"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reposRemoveCollaborator(
    p: {
      owner: string
      repo: string
      username: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<204, void> | Res<403, t_basic_error> | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/collaborators/${p["username"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async reposGetCollaboratorPermissionLevel(
    p: {
      owner: string
      repo: string
      username: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_repository_collaborator_permission> | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/collaborators/${p["username"]}/permission`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposListCommitCommentsForRepo(
    p: {
      owner: string
      repo: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_commit_comment[]>>> {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/comments`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposGetCommitComment(
    p: {
      owner: string
      repo: string
      commentId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_commit_comment> | Res<404, t_basic_error>>
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/comments/${p["commentId"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposUpdateCommitComment(
    p: {
      owner: string
      repo: string
      commentId: number
      requestBody: t_reposUpdateCommitCommentJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_commit_comment> | Res<404, t_basic_error>>
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/comments/${p["commentId"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PATCH", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reposDeleteCommitComment(
    p: {
      owner: string
      repo: string
      commentId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void> | Res<404, t_basic_error>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/comments/${p["commentId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async reactionsListForCommitComment(
    p: {
      owner: string
      repo: string
      commentId: number
      content?:
        | "+1"
        | "-1"
        | "laugh"
        | "confused"
        | "heart"
        | "hooray"
        | "rocket"
        | "eyes"
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_reaction[]> | Res<404, t_basic_error>>
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/comments/${p["commentId"]}/reactions`
    const query = this._query({
      content: p["content"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reactionsCreateForCommitComment(
    p: {
      owner: string
      repo: string
      commentId: number
      requestBody: t_reactionsCreateForCommitCommentJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_reaction> | Res<201, t_reaction> | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/comments/${p["commentId"]}/reactions`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reactionsDeleteForCommitComment(
    p: {
      owner: string
      repo: string
      commentId: number
      reactionId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/comments/${p["commentId"]}/reactions/${p["reactionId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async reposListCommits(
    p: {
      owner: string
      repo: string
      sha?: string
      path?: string
      author?: string
      committer?: string
      since?: string
      until?: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_commit[]>
      | Res<400, t_scim_error>
      | Res<404, t_basic_error>
      | Res<409, t_basic_error>
      | Res<500, t_basic_error>
    >
  > {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/commits`
    const query = this._query({
      sha: p["sha"],
      path: p["path"],
      author: p["author"],
      committer: p["committer"],
      since: p["since"],
      until: p["until"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposListBranchesForHeadCommit(
    p: {
      owner: string
      repo: string
      commitSha: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_branch_short[]>
      | Res<409, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/commits/${p["commitSha"]}/branches-where-head`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposListCommentsForCommit(
    p: {
      owner: string
      repo: string
      commitSha: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_commit_comment[]>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/commits/${p["commitSha"]}/comments`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposCreateCommitComment(
    p: {
      owner: string
      repo: string
      commitSha: string
      requestBody: t_reposCreateCommitCommentJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_commit_comment>
      | Res<403, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/commits/${p["commitSha"]}/comments`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reposListPullRequestsAssociatedWithCommit(
    p: {
      owner: string
      repo: string
      commitSha: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_pull_request_simple[]> | Res<409, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/commits/${p["commitSha"]}/pulls`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposGetCommit(
    p: {
      owner: string
      repo: string
      page?: number
      perPage?: number
      ref: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_commit>
      | Res<404, t_basic_error>
      | Res<409, t_basic_error>
      | Res<422, t_validation_error>
      | Res<500, t_basic_error>
      | Res<503, t_reposGetCommitJson503Response>
    >
  > {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/commits/${p["ref"]}`
    const query = this._query({page: p["page"], per_page: p["perPage"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async checksListForRef(
    p: {
      owner: string
      repo: string
      ref: string
      checkName?: string
      status?: "queued" | "in_progress" | "completed"
      filter?: "latest" | "all"
      perPage?: number
      page?: number
      appId?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_checksListForRefJson200Response>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/commits/${p["ref"]}/check-runs`
    const query = this._query({
      check_name: p["checkName"],
      status: p["status"],
      filter: p["filter"],
      per_page: p["perPage"],
      page: p["page"],
      app_id: p["appId"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async checksListSuitesForRef(
    p: {
      owner: string
      repo: string
      ref: string
      appId?: number
      checkName?: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_checksListSuitesForRefJson200Response>>
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/commits/${p["ref"]}/check-suites`
    const query = this._query({
      app_id: p["appId"],
      check_name: p["checkName"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposGetCombinedStatusForRef(
    p: {
      owner: string
      repo: string
      ref: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_combined_commit_status> | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/commits/${p["ref"]}/status`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposListCommitStatusesForRef(
    p: {
      owner: string
      repo: string
      ref: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_status[]> | Res<301, t_basic_error>>
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/commits/${p["ref"]}/statuses`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposGetCommunityProfileMetrics(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_community_profile>>> {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/community/profile`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposCompareCommits(
    p: {
      owner: string
      repo: string
      page?: number
      perPage?: number
      basehead: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_commit_comparison>
      | Res<404, t_basic_error>
      | Res<500, t_basic_error>
      | Res<503, t_reposCompareCommitsJson503Response>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/compare/${p["basehead"]}`
    const query = this._query({page: p["page"], per_page: p["perPage"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposGetContent(
    p: {
      owner: string
      repo: string
      path: string
      ref?: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_reposGetContentJson200Response>
      | Res<302, void>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/contents/${p["path"]}`
    const query = this._query({ref: p["ref"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposCreateOrUpdateFileContents(
    p: {
      owner: string
      repo: string
      path: string
      requestBody: t_reposCreateOrUpdateFileContentsJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_file_commit>
      | Res<201, t_file_commit>
      | Res<404, t_basic_error>
      | Res<409, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/contents/${p["path"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reposDeleteFile(
    p: {
      owner: string
      repo: string
      path: string
      requestBody: t_reposDeleteFileJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_file_commit>
      | Res<404, t_basic_error>
      | Res<409, t_basic_error>
      | Res<422, t_validation_error>
      | Res<503, t_reposDeleteFileJson503Response>
    >
  > {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/contents/${p["path"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "DELETE", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reposListContributors(
    p: {
      owner: string
      repo: string
      anon?: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_contributor[]>
      | Res<204, void>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/contributors`
    const query = this._query({
      anon: p["anon"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async dependabotListAlertsForRepo(
    p: {
      owner: string
      repo: string
      state?: string
      severity?: string
      ecosystem?: string
      package?: string
      manifest?: string
      scope?: "development" | "runtime"
      sort?: "created" | "updated"
      direction?: "asc" | "desc"
      page?: number
      perPage?: number
      before?: string
      after?: string
      first?: number
      last?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_dependabot_alert[]>
      | Res<304, void>
      | Res<400, t_scim_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error_simple>
    >
  > {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/dependabot/alerts`
    const query = this._query({
      state: p["state"],
      severity: p["severity"],
      ecosystem: p["ecosystem"],
      package: p["package"],
      manifest: p["manifest"],
      scope: p["scope"],
      sort: p["sort"],
      direction: p["direction"],
      page: p["page"],
      per_page: p["perPage"],
      before: p["before"],
      after: p["after"],
      first: p["first"],
      last: p["last"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async dependabotGetAlert(
    p: {
      owner: string
      repo: string
      alertNumber: t_alert_number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_dependabot_alert>
      | Res<304, void>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/dependabot/alerts/${p["alertNumber"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async dependabotUpdateAlert(
    p: {
      owner: string
      repo: string
      alertNumber: t_alert_number
      requestBody: t_dependabotUpdateAlertJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_dependabot_alert>
      | Res<400, t_scim_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<409, t_basic_error>
      | Res<422, t_validation_error_simple>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/dependabot/alerts/${p["alertNumber"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PATCH", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async dependabotListRepoSecrets(
    p: {
      owner: string
      repo: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_dependabotListRepoSecretsJson200Response>>
  > {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/dependabot/secrets`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async dependabotGetRepoPublicKey(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_dependabot_public_key>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/dependabot/secrets/public-key`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async dependabotGetRepoSecret(
    p: {
      owner: string
      repo: string
      secretName: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_dependabot_secret>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/dependabot/secrets/${p["secretName"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async dependabotCreateOrUpdateRepoSecret(
    p: {
      owner: string
      repo: string
      secretName: string
      requestBody: t_dependabotCreateOrUpdateRepoSecretJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<201, t_empty_object> | Res<204, void>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/dependabot/secrets/${p["secretName"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async dependabotDeleteRepoSecret(
    p: {
      owner: string
      repo: string
      secretName: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/dependabot/secrets/${p["secretName"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async dependencyGraphDiffRange(
    p: {
      owner: string
      repo: string
      basehead: string
      name?: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_dependency_graph_diff>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/dependency-graph/compare/${p["basehead"]}`
    const query = this._query({name: p["name"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async dependencyGraphExportSbom(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_dependency_graph_spdx_sbom>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/dependency-graph/sbom`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async dependencyGraphCreateRepositorySnapshot(
    p: {
      owner: string
      repo: string
      requestBody: t_snapshot
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<201, t_dependencyGraphCreateRepositorySnapshotJson201Response>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/dependency-graph/snapshots`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reposListDeployments(
    p: {
      owner: string
      repo: string
      sha?: string
      ref?: string
      task?: string
      environment?: string | null
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_deployment[]>>> {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/deployments`
    const query = this._query({
      sha: p["sha"],
      ref: p["ref"],
      task: p["task"],
      environment: p["environment"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposCreateDeployment(
    p: {
      owner: string
      repo: string
      requestBody: t_reposCreateDeploymentJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_deployment>
      | Res<202, t_reposCreateDeploymentJson202Response>
      | Res<409, void>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/deployments`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reposGetDeployment(
    p: {
      owner: string
      repo: string
      deploymentId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_deployment> | Res<404, t_basic_error>>
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/deployments/${p["deploymentId"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposDeleteDeployment(
    p: {
      owner: string
      repo: string
      deploymentId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error_simple>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/deployments/${p["deploymentId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async reposListDeploymentStatuses(
    p: {
      owner: string
      repo: string
      deploymentId: number
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_deployment_status[]> | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/deployments/${p["deploymentId"]}/statuses`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposCreateDeploymentStatus(
    p: {
      owner: string
      repo: string
      deploymentId: number
      requestBody: t_reposCreateDeploymentStatusJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<201, t_deployment_status> | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/deployments/${p["deploymentId"]}/statuses`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reposGetDeploymentStatus(
    p: {
      owner: string
      repo: string
      deploymentId: number
      statusId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_deployment_status> | Res<404, t_basic_error>>
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/deployments/${p["deploymentId"]}/statuses/${p["statusId"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposCreateDispatchEvent(
    p: {
      owner: string
      repo: string
      requestBody: t_reposCreateDispatchEventJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<204, void> | Res<404, t_basic_error> | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/dispatches`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reposGetAllEnvironments(
    p: {
      owner: string
      repo: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_reposGetAllEnvironmentsJson200Response>>
  > {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/environments`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposGetEnvironment(
    p: {
      owner: string
      repo: string
      environmentName: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_environment>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/environments/${p["environmentName"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposCreateOrUpdateEnvironment(
    p: {
      owner: string
      repo: string
      environmentName: string
      requestBody?: t_reposCreateOrUpdateEnvironmentJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_environment> | Res<422, t_basic_error>>
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/environments/${p["environmentName"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reposDeleteAnEnvironment(
    p: {
      owner: string
      repo: string
      environmentName: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/environments/${p["environmentName"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async reposListDeploymentBranchPolicies(
    p: {
      owner: string
      repo: string
      environmentName: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_reposListDeploymentBranchPoliciesJson200Response>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/environments/${p["environmentName"]}/deployment-branch-policies`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposCreateDeploymentBranchPolicy(
    p: {
      owner: string
      repo: string
      environmentName: string
      requestBody: t_deployment_branch_policy_name_pattern_with_type
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_deployment_branch_policy> | Res<303, void> | Res<404, void>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/environments/${p["environmentName"]}/deployment-branch-policies`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reposGetDeploymentBranchPolicy(
    p: {
      owner: string
      repo: string
      environmentName: string
      branchPolicyId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_deployment_branch_policy>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/environments/${p["environmentName"]}/deployment-branch-policies/${p["branchPolicyId"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposUpdateDeploymentBranchPolicy(
    p: {
      owner: string
      repo: string
      environmentName: string
      branchPolicyId: number
      requestBody: t_deployment_branch_policy_name_pattern
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_deployment_branch_policy>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/environments/${p["environmentName"]}/deployment-branch-policies/${p["branchPolicyId"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reposDeleteDeploymentBranchPolicy(
    p: {
      owner: string
      repo: string
      environmentName: string
      branchPolicyId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/environments/${p["environmentName"]}/deployment-branch-policies/${p["branchPolicyId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async reposGetAllDeploymentProtectionRules(
    p: {
      environmentName: string
      repo: string
      owner: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_reposGetAllDeploymentProtectionRulesJson200Response>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/environments/${p["environmentName"]}/deployment_protection_rules`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposCreateDeploymentProtectionRule(
    p: {
      environmentName: string
      repo: string
      owner: string
      requestBody: t_reposCreateDeploymentProtectionRuleJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<201, t_deployment_protection_rule>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/environments/${p["environmentName"]}/deployment_protection_rules`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reposListCustomDeploymentRuleIntegrations(
    p: {
      environmentName: string
      repo: string
      owner: string
      page?: number
      perPage?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_reposListCustomDeploymentRuleIntegrationsJson200Response>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/environments/${p["environmentName"]}/deployment_protection_rules/apps`
    const query = this._query({page: p["page"], per_page: p["perPage"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposGetCustomDeploymentProtectionRule(
    p: {
      owner: string
      repo: string
      environmentName: string
      protectionRuleId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_deployment_protection_rule>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/environments/${p["environmentName"]}/deployment_protection_rules/${p["protectionRuleId"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposDisableDeploymentProtectionRule(
    p: {
      environmentName: string
      repo: string
      owner: string
      protectionRuleId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/environments/${p["environmentName"]}/deployment_protection_rules/${p["protectionRuleId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async actionsListEnvironmentSecrets(
    p: {
      owner: string
      repo: string
      environmentName: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_actionsListEnvironmentSecretsJson200Response>>
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/environments/${p["environmentName"]}/secrets`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsGetEnvironmentPublicKey(
    p: {
      owner: string
      repo: string
      environmentName: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_actions_public_key>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/environments/${p["environmentName"]}/secrets/public-key`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsGetEnvironmentSecret(
    p: {
      owner: string
      repo: string
      environmentName: string
      secretName: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_actions_secret>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/environments/${p["environmentName"]}/secrets/${p["secretName"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsCreateOrUpdateEnvironmentSecret(
    p: {
      owner: string
      repo: string
      environmentName: string
      secretName: string
      requestBody: t_actionsCreateOrUpdateEnvironmentSecretJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<201, t_empty_object> | Res<204, void>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/environments/${p["environmentName"]}/secrets/${p["secretName"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async actionsDeleteEnvironmentSecret(
    p: {
      owner: string
      repo: string
      environmentName: string
      secretName: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/environments/${p["environmentName"]}/secrets/${p["secretName"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async actionsListEnvironmentVariables(
    p: {
      owner: string
      repo: string
      environmentName: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_actionsListEnvironmentVariablesJson200Response>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/environments/${p["environmentName"]}/variables`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsCreateEnvironmentVariable(
    p: {
      owner: string
      repo: string
      environmentName: string
      requestBody: t_actionsCreateEnvironmentVariableJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<201, t_empty_object>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/environments/${p["environmentName"]}/variables`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async actionsGetEnvironmentVariable(
    p: {
      owner: string
      repo: string
      environmentName: string
      name: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_actions_variable>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/environments/${p["environmentName"]}/variables/${p["name"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async actionsUpdateEnvironmentVariable(
    p: {
      owner: string
      repo: string
      name: string
      environmentName: string
      requestBody: t_actionsUpdateEnvironmentVariableJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/environments/${p["environmentName"]}/variables/${p["name"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PATCH", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async actionsDeleteEnvironmentVariable(
    p: {
      owner: string
      repo: string
      name: string
      environmentName: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/environments/${p["environmentName"]}/variables/${p["name"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async activityListRepoEvents(
    p: {
      owner: string
      repo: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_event[]>>> {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/events`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposListForks(
    p: {
      owner: string
      repo: string
      sort?: "newest" | "oldest" | "stargazers" | "watchers"
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_minimal_repository[]> | Res<400, t_scim_error>
    >
  > {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/forks`
    const query = this._query({
      sort: p["sort"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposCreateFork(
    p: {
      owner: string
      repo: string
      requestBody?: t_reposCreateForkJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<202, t_full_repository>
      | Res<400, t_scim_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/forks`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async gitCreateBlob(
    p: {
      owner: string
      repo: string
      requestBody: t_gitCreateBlobJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_short_blob>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<409, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/git/blobs`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async gitGetBlob(
    p: {
      owner: string
      repo: string
      fileSha: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_blob>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<409, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/git/blobs/${p["fileSha"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async gitCreateCommit(
    p: {
      owner: string
      repo: string
      requestBody: t_gitCreateCommitJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_git_commit>
      | Res<404, t_basic_error>
      | Res<409, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/git/commits`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async gitGetCommit(
    p: {
      owner: string
      repo: string
      commitSha: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_git_commit> | Res<404, t_basic_error> | Res<409, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/git/commits/${p["commitSha"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async gitListMatchingRefs(
    p: {
      owner: string
      repo: string
      ref: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_git_ref[]> | Res<409, t_basic_error>>
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/git/matching-refs/${p["ref"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async gitGetRef(
    p: {
      owner: string
      repo: string
      ref: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_git_ref> | Res<404, t_basic_error> | Res<409, t_basic_error>
    >
  > {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/git/ref/${p["ref"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async gitCreateRef(
    p: {
      owner: string
      repo: string
      requestBody: t_gitCreateRefJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_git_ref>
      | Res<409, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/git/refs`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async gitUpdateRef(
    p: {
      owner: string
      repo: string
      ref: string
      requestBody: t_gitUpdateRefJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_git_ref>
      | Res<409, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/git/refs/${p["ref"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PATCH", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async gitDeleteRef(
    p: {
      owner: string
      repo: string
      ref: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<204, void> | Res<409, t_basic_error> | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/git/refs/${p["ref"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async gitCreateTag(
    p: {
      owner: string
      repo: string
      requestBody: t_gitCreateTagJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_git_tag>
      | Res<409, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/git/tags`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async gitGetTag(
    p: {
      owner: string
      repo: string
      tagSha: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_git_tag> | Res<404, t_basic_error> | Res<409, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/git/tags/${p["tagSha"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async gitCreateTree(
    p: {
      owner: string
      repo: string
      requestBody: t_gitCreateTreeJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_git_tree>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<409, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/git/trees`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async gitGetTree(
    p: {
      owner: string
      repo: string
      treeSha: string
      recursive?: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_git_tree>
      | Res<404, t_basic_error>
      | Res<409, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/git/trees/${p["treeSha"]}`
    const query = this._query({recursive: p["recursive"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposListWebhooks(
    p: {
      owner: string
      repo: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_hook[]> | Res<404, t_basic_error>>> {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/hooks`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposCreateWebhook(
    p: {
      owner: string
      repo: string
      requestBody?: t_reposCreateWebhookJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_hook>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/hooks`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reposGetWebhook(
    p: {
      owner: string
      repo: string
      hookId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_hook> | Res<404, t_basic_error>>> {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/hooks/${p["hookId"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposUpdateWebhook(
    p: {
      owner: string
      repo: string
      hookId: number
      requestBody: t_reposUpdateWebhookJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_hook> | Res<404, t_basic_error> | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/hooks/${p["hookId"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PATCH", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reposDeleteWebhook(
    p: {
      owner: string
      repo: string
      hookId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void> | Res<404, t_basic_error>>> {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/hooks/${p["hookId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async reposGetWebhookConfigForRepo(
    p: {
      owner: string
      repo: string
      hookId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_webhook_config>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/hooks/${p["hookId"]}/config`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposUpdateWebhookConfigForRepo(
    p: {
      owner: string
      repo: string
      hookId: number
      requestBody?: t_reposUpdateWebhookConfigForRepoJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_webhook_config>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/hooks/${p["hookId"]}/config`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PATCH", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reposListWebhookDeliveries(
    p: {
      owner: string
      repo: string
      hookId: number
      perPage?: number
      cursor?: string
      redelivery?: boolean
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_hook_delivery_item[]>
      | Res<400, t_scim_error>
      | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/hooks/${p["hookId"]}/deliveries`
    const query = this._query({
      per_page: p["perPage"],
      cursor: p["cursor"],
      redelivery: p["redelivery"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposGetWebhookDelivery(
    p: {
      owner: string
      repo: string
      hookId: number
      deliveryId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_hook_delivery>
      | Res<400, t_scim_error>
      | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/hooks/${p["hookId"]}/deliveries/${p["deliveryId"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposRedeliverWebhookDelivery(
    p: {
      owner: string
      repo: string
      hookId: number
      deliveryId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<202, t_reposRedeliverWebhookDeliveryJson202Response>
      | Res<400, t_scim_error>
      | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/hooks/${p["hookId"]}/deliveries/${p["deliveryId"]}/attempts`

    return this._fetch(url, {method: "POST", ...(opts ?? {})}, timeout)
  }

  async reposPingWebhook(
    p: {
      owner: string
      repo: string
      hookId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void> | Res<404, t_basic_error>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/hooks/${p["hookId"]}/pings`

    return this._fetch(url, {method: "POST", ...(opts ?? {})}, timeout)
  }

  async reposTestPushWebhook(
    p: {
      owner: string
      repo: string
      hookId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void> | Res<404, t_basic_error>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/hooks/${p["hookId"]}/tests`

    return this._fetch(url, {method: "POST", ...(opts ?? {})}, timeout)
  }

  async migrationsGetImportStatus(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_import> | Res<404, t_basic_error> | Res<503, t_basic_error>
    >
  > {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/import`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async migrationsStartImport(
    p: {
      owner: string
      repo: string
      requestBody: t_migrationsStartImportJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_import>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
      | Res<503, t_basic_error>
    >
  > {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/import`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async migrationsUpdateImport(
    p: {
      owner: string
      repo: string
      requestBody?: t_migrationsUpdateImportJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_import> | Res<503, t_basic_error>>> {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/import`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PATCH", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async migrationsCancelImport(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void> | Res<503, t_basic_error>>> {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/import`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async migrationsGetCommitAuthors(
    p: {
      owner: string
      repo: string
      since?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_porter_author[]>
      | Res<404, t_basic_error>
      | Res<503, t_basic_error>
    >
  > {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/import/authors`
    const query = this._query({since: p["since"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async migrationsMapCommitAuthor(
    p: {
      owner: string
      repo: string
      authorId: number
      requestBody?: t_migrationsMapCommitAuthorJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_porter_author>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
      | Res<503, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/import/authors/${p["authorId"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PATCH", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async migrationsGetLargeFiles(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_porter_large_file[]> | Res<503, t_basic_error>
    >
  > {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/import/large_files`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async migrationsSetLfsPreference(
    p: {
      owner: string
      repo: string
      requestBody: t_migrationsSetLfsPreferenceJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_import>
      | Res<422, t_validation_error>
      | Res<503, t_basic_error>
    >
  > {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/import/lfs`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PATCH", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async appsGetRepoInstallation(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_installation>
      | Res<301, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/installation`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async interactionsGetRestrictionsForRepo(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_interactionsGetRestrictionsForRepoJson200Response>
    >
  > {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/interaction-limits`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async interactionsSetRestrictionsForRepo(
    p: {
      owner: string
      repo: string
      requestBody: t_interaction_limit
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_interaction_limit_response> | Res<409, void>>
  > {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/interaction-limits`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async interactionsRemoveRestrictionsForRepo(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void> | Res<409, void>>> {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/interaction-limits`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async reposListInvitations(
    p: {
      owner: string
      repo: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_repository_invitation[]>>> {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/invitations`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposUpdateInvitation(
    p: {
      owner: string
      repo: string
      invitationId: number
      requestBody?: t_reposUpdateInvitationJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_repository_invitation>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/invitations/${p["invitationId"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PATCH", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reposDeleteInvitation(
    p: {
      owner: string
      repo: string
      invitationId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/invitations/${p["invitationId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async issuesListForRepo(
    p: {
      owner: string
      repo: string
      milestone?: string
      state?: "open" | "closed" | "all"
      assignee?: string
      creator?: string
      mentioned?: string
      labels?: string
      sort?: "created" | "updated" | "comments"
      direction?: "asc" | "desc"
      since?: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_issue[]>
      | Res<301, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/issues`
    const query = this._query({
      milestone: p["milestone"],
      state: p["state"],
      assignee: p["assignee"],
      creator: p["creator"],
      mentioned: p["mentioned"],
      labels: p["labels"],
      sort: p["sort"],
      direction: p["direction"],
      since: p["since"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async issuesCreate(
    p: {
      owner: string
      repo: string
      requestBody: t_issuesCreateJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_issue>
      | Res<400, t_scim_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<410, t_basic_error>
      | Res<422, t_validation_error>
      | Res<503, t_issuesCreateJson503Response>
    >
  > {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/issues`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async issuesListCommentsForRepo(
    p: {
      owner: string
      repo: string
      sort?: "created" | "updated"
      direction?: "asc" | "desc"
      since?: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_issue_comment[]>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/issues/comments`
    const query = this._query({
      sort: p["sort"],
      direction: p["direction"],
      since: p["since"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async issuesGetComment(
    p: {
      owner: string
      repo: string
      commentId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_issue_comment> | Res<404, t_basic_error>>
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/issues/comments/${p["commentId"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async issuesUpdateComment(
    p: {
      owner: string
      repo: string
      commentId: number
      requestBody: t_issuesUpdateCommentJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_issue_comment> | Res<422, t_validation_error>>
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/issues/comments/${p["commentId"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PATCH", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async issuesDeleteComment(
    p: {
      owner: string
      repo: string
      commentId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/issues/comments/${p["commentId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async reactionsListForIssueComment(
    p: {
      owner: string
      repo: string
      commentId: number
      content?:
        | "+1"
        | "-1"
        | "laugh"
        | "confused"
        | "heart"
        | "hooray"
        | "rocket"
        | "eyes"
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_reaction[]> | Res<404, t_basic_error>>
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/issues/comments/${p["commentId"]}/reactions`
    const query = this._query({
      content: p["content"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reactionsCreateForIssueComment(
    p: {
      owner: string
      repo: string
      commentId: number
      requestBody: t_reactionsCreateForIssueCommentJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_reaction> | Res<201, t_reaction> | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/issues/comments/${p["commentId"]}/reactions`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reactionsDeleteForIssueComment(
    p: {
      owner: string
      repo: string
      commentId: number
      reactionId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/issues/comments/${p["commentId"]}/reactions/${p["reactionId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async issuesListEventsForRepo(
    p: {
      owner: string
      repo: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_issue_event[]> | Res<422, t_validation_error>>
  > {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/issues/events`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async issuesGetEvent(
    p: {
      owner: string
      repo: string
      eventId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_issue_event>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<410, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/issues/events/${p["eventId"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async issuesGet(
    p: {
      owner: string
      repo: string
      issueNumber: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_issue>
      | Res<301, t_basic_error>
      | Res<304, void>
      | Res<404, t_basic_error>
      | Res<410, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async issuesUpdate(
    p: {
      owner: string
      repo: string
      issueNumber: number
      requestBody?: t_issuesUpdateJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_issue>
      | Res<301, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<410, t_basic_error>
      | Res<422, t_validation_error>
      | Res<503, t_issuesUpdateJson503Response>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PATCH", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async issuesAddAssignees(
    p: {
      owner: string
      repo: string
      issueNumber: number
      requestBody?: t_issuesAddAssigneesJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<201, t_issue>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/assignees`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async issuesRemoveAssignees(
    p: {
      owner: string
      repo: string
      issueNumber: number
      requestBody: t_issuesRemoveAssigneesJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_issue>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/assignees`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "DELETE", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async issuesCheckUserCanBeAssignedToIssue(
    p: {
      owner: string
      repo: string
      issueNumber: number
      assignee: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void> | Res<404, t_basic_error>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/assignees/${p["assignee"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async issuesListComments(
    p: {
      owner: string
      repo: string
      issueNumber: number
      since?: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_issue_comment[]>
      | Res<404, t_basic_error>
      | Res<410, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/comments`
    const query = this._query({
      since: p["since"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async issuesCreateComment(
    p: {
      owner: string
      repo: string
      issueNumber: number
      requestBody: t_issuesCreateCommentJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_issue_comment>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<410, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/comments`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async issuesListEvents(
    p: {
      owner: string
      repo: string
      issueNumber: number
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_issue_event_for_issue[]> | Res<410, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/events`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async issuesListLabelsOnIssue(
    p: {
      owner: string
      repo: string
      issueNumber: number
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_label[]>
      | Res<301, t_basic_error>
      | Res<404, t_basic_error>
      | Res<410, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/labels`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async issuesAddLabels(
    p: {
      owner: string
      repo: string
      issueNumber: number
      requestBody?: t_issuesAddLabelsJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_label[]>
      | Res<301, t_basic_error>
      | Res<404, t_basic_error>
      | Res<410, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/labels`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async issuesSetLabels(
    p: {
      owner: string
      repo: string
      issueNumber: number
      requestBody?: t_issuesSetLabelsJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_label[]>
      | Res<301, t_basic_error>
      | Res<404, t_basic_error>
      | Res<410, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/labels`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async issuesRemoveAllLabels(
    p: {
      owner: string
      repo: string
      issueNumber: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<301, t_basic_error>
      | Res<404, t_basic_error>
      | Res<410, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/labels`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async issuesRemoveLabel(
    p: {
      owner: string
      repo: string
      issueNumber: number
      name: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_label[]>
      | Res<301, t_basic_error>
      | Res<404, t_basic_error>
      | Res<410, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/labels/${p["name"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async issuesLock(
    p: {
      owner: string
      repo: string
      issueNumber: number
      requestBody?: t_issuesLockJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<410, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/lock`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async issuesUnlock(
    p: {
      owner: string
      repo: string
      issueNumber: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<204, void> | Res<403, t_basic_error> | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/lock`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async reactionsListForIssue(
    p: {
      owner: string
      repo: string
      issueNumber: number
      content?:
        | "+1"
        | "-1"
        | "laugh"
        | "confused"
        | "heart"
        | "hooray"
        | "rocket"
        | "eyes"
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_reaction[]> | Res<404, t_basic_error> | Res<410, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/reactions`
    const query = this._query({
      content: p["content"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reactionsCreateForIssue(
    p: {
      owner: string
      repo: string
      issueNumber: number
      requestBody: t_reactionsCreateForIssueJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_reaction> | Res<201, t_reaction> | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/reactions`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reactionsDeleteForIssue(
    p: {
      owner: string
      repo: string
      issueNumber: number
      reactionId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/reactions/${p["reactionId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async issuesListEventsForTimeline(
    p: {
      owner: string
      repo: string
      issueNumber: number
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_timeline_issue_events[]>
      | Res<404, t_basic_error>
      | Res<410, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/issues/${p["issueNumber"]}/timeline`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposListDeployKeys(
    p: {
      owner: string
      repo: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_deploy_key[]>>> {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/keys`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposCreateDeployKey(
    p: {
      owner: string
      repo: string
      requestBody: t_reposCreateDeployKeyJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<201, t_deploy_key> | Res<422, t_validation_error>>
  > {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/keys`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reposGetDeployKey(
    p: {
      owner: string
      repo: string
      keyId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_deploy_key> | Res<404, t_basic_error>>
  > {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/keys/${p["keyId"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposDeleteDeployKey(
    p: {
      owner: string
      repo: string
      keyId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/keys/${p["keyId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async issuesListLabelsForRepo(
    p: {
      owner: string
      repo: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_label[]> | Res<404, t_basic_error>>
  > {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/labels`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async issuesCreateLabel(
    p: {
      owner: string
      repo: string
      requestBody: t_issuesCreateLabelJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<201, t_label> | Res<404, t_basic_error> | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/labels`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async issuesGetLabel(
    p: {
      owner: string
      repo: string
      name: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_label> | Res<404, t_basic_error>>> {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/labels/${p["name"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async issuesUpdateLabel(
    p: {
      owner: string
      repo: string
      name: string
      requestBody?: t_issuesUpdateLabelJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_label>>> {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/labels/${p["name"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PATCH", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async issuesDeleteLabel(
    p: {
      owner: string
      repo: string
      name: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/labels/${p["name"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async reposListLanguages(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_language>>> {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/languages`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async licensesGetForRepo(
    p: {
      owner: string
      repo: string
      ref?: t_code_scanning_ref
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_license_content> | Res<404, t_basic_error>>
  > {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/license`
    const query = this._query({ref: p["ref"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposMergeUpstream(
    p: {
      owner: string
      repo: string
      requestBody: t_reposMergeUpstreamJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_merged_upstream> | Res<409, void> | Res<422, void>
    >
  > {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/merge-upstream`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reposMerge(
    p: {
      owner: string
      repo: string
      requestBody: t_reposMergeJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_commit>
      | Res<204, void>
      | Res<403, t_basic_error>
      | Res<404, void>
      | Res<409, void>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/merges`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async issuesListMilestones(
    p: {
      owner: string
      repo: string
      state?: "open" | "closed" | "all"
      sort?: "due_on" | "completeness"
      direction?: "asc" | "desc"
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_milestone[]> | Res<404, t_basic_error>>
  > {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/milestones`
    const query = this._query({
      state: p["state"],
      sort: p["sort"],
      direction: p["direction"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async issuesCreateMilestone(
    p: {
      owner: string
      repo: string
      requestBody: t_issuesCreateMilestoneJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_milestone>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/milestones`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async issuesGetMilestone(
    p: {
      owner: string
      repo: string
      milestoneNumber: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_milestone> | Res<404, t_basic_error>>
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/milestones/${p["milestoneNumber"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async issuesUpdateMilestone(
    p: {
      owner: string
      repo: string
      milestoneNumber: number
      requestBody?: t_issuesUpdateMilestoneJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_milestone>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/milestones/${p["milestoneNumber"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PATCH", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async issuesDeleteMilestone(
    p: {
      owner: string
      repo: string
      milestoneNumber: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void> | Res<404, t_basic_error>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/milestones/${p["milestoneNumber"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async issuesListLabelsForMilestone(
    p: {
      owner: string
      repo: string
      milestoneNumber: number
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_label[]>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/milestones/${p["milestoneNumber"]}/labels`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async activityListRepoNotificationsForAuthenticatedUser(
    p: {
      owner: string
      repo: string
      all?: boolean
      participating?: boolean
      since?: string
      before?: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_thread[]>>> {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/notifications`
    const query = this._query({
      all: p["all"],
      participating: p["participating"],
      since: p["since"],
      before: p["before"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async activityMarkRepoNotificationsAsRead(
    p: {
      owner: string
      repo: string
      requestBody?: t_activityMarkRepoNotificationsAsReadJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<202, t_activityMarkRepoNotificationsAsReadJson202Response>
      | Res<205, void>
    >
  > {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/notifications`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reposGetPages(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_page> | Res<404, t_basic_error>>> {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/pages`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposCreatePagesSite(
    p: {
      owner: string
      repo: string
      requestBody: t_reposCreatePagesSiteJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<201, t_page> | Res<409, t_basic_error> | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/pages`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reposUpdateInformationAboutPagesSite(
    p: {
      owner: string
      repo: string
      requestBody: t_reposUpdateInformationAboutPagesSiteJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<400, t_scim_error>
      | Res<409, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/pages`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reposDeletePagesSite(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<404, t_basic_error>
      | Res<409, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/pages`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async reposListPagesBuilds(
    p: {
      owner: string
      repo: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_page_build[]>>> {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/pages/builds`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposRequestPagesBuild(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<201, t_page_build_status>>> {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/pages/builds`

    return this._fetch(url, {method: "POST", ...(opts ?? {})}, timeout)
  }

  async reposGetLatestPagesBuild(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_page_build>>> {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/pages/builds/latest`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposGetPagesBuild(
    p: {
      owner: string
      repo: string
      buildId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_page_build>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/pages/builds/${p["buildId"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposCreatePagesDeployment(
    p: {
      owner: string
      repo: string
      requestBody: t_reposCreatePagesDeploymentJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_page_deployment>
      | Res<400, t_scim_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/pages/deployments`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reposGetPagesDeployment(
    p: {
      owner: string
      repo: string
      pagesDeploymentId: number | string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_pages_deployment_status> | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/pages/deployments/${p["pagesDeploymentId"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposCancelPagesDeployment(
    p: {
      owner: string
      repo: string
      pagesDeploymentId: number | string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void> | Res<404, t_basic_error>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/pages/deployments/${p["pagesDeploymentId"]}/cancel`

    return this._fetch(url, {method: "POST", ...(opts ?? {})}, timeout)
  }

  async reposGetPagesHealthCheck(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_pages_health_check>
      | Res<202, t_empty_object>
      | Res<400, void>
      | Res<404, t_basic_error>
      | Res<422, void>
    >
  > {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/pages/health`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposCheckPrivateVulnerabilityReporting(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_reposCheckPrivateVulnerabilityReportingJson200Response>
      | Res<422, t_scim_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/private-vulnerability-reporting`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposEnablePrivateVulnerabilityReporting(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void> | Res<422, t_scim_error>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/private-vulnerability-reporting`

    return this._fetch(url, {method: "PUT", ...(opts ?? {})}, timeout)
  }

  async reposDisablePrivateVulnerabilityReporting(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void> | Res<422, t_scim_error>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/private-vulnerability-reporting`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async projectsListForRepo(
    p: {
      owner: string
      repo: string
      state?: "open" | "closed" | "all"
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_project[]>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<410, t_basic_error>
      | Res<422, t_validation_error_simple>
    >
  > {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/projects`
    const query = this._query({
      state: p["state"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async projectsCreateForRepo(
    p: {
      owner: string
      repo: string
      requestBody: t_projectsCreateForRepoJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_project>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<410, t_basic_error>
      | Res<422, t_validation_error_simple>
    >
  > {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/projects`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reposGetCustomPropertiesValues(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_custom_property_value[]>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/properties/values`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposCreateOrUpdateCustomPropertiesValues(
    p: {
      owner: string
      repo: string
      requestBody: t_reposCreateOrUpdateCustomPropertiesValuesJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/properties/values`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PATCH", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async pullsList(
    p: {
      owner: string
      repo: string
      state?: "open" | "closed" | "all"
      head?: string
      base?: string
      sort?: "created" | "updated" | "popularity" | "long-running"
      direction?: "asc" | "desc"
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_pull_request_simple[]>
      | Res<304, void>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/pulls`
    const query = this._query({
      state: p["state"],
      head: p["head"],
      base: p["base"],
      sort: p["sort"],
      direction: p["direction"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async pullsCreate(
    p: {
      owner: string
      repo: string
      requestBody: t_pullsCreateJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_pull_request>
      | Res<403, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/pulls`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async pullsListReviewCommentsForRepo(
    p: {
      owner: string
      repo: string
      sort?: "created" | "updated" | "created_at"
      direction?: "asc" | "desc"
      since?: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_pull_request_review_comment[]>>> {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/pulls/comments`
    const query = this._query({
      sort: p["sort"],
      direction: p["direction"],
      since: p["since"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async pullsGetReviewComment(
    p: {
      owner: string
      repo: string
      commentId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_pull_request_review_comment> | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/pulls/comments/${p["commentId"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async pullsUpdateReviewComment(
    p: {
      owner: string
      repo: string
      commentId: number
      requestBody: t_pullsUpdateReviewCommentJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_pull_request_review_comment>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/pulls/comments/${p["commentId"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PATCH", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async pullsDeleteReviewComment(
    p: {
      owner: string
      repo: string
      commentId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void> | Res<404, t_basic_error>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/pulls/comments/${p["commentId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async reactionsListForPullRequestReviewComment(
    p: {
      owner: string
      repo: string
      commentId: number
      content?:
        | "+1"
        | "-1"
        | "laugh"
        | "confused"
        | "heart"
        | "hooray"
        | "rocket"
        | "eyes"
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_reaction[]> | Res<404, t_basic_error>>
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/pulls/comments/${p["commentId"]}/reactions`
    const query = this._query({
      content: p["content"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reactionsCreateForPullRequestReviewComment(
    p: {
      owner: string
      repo: string
      commentId: number
      requestBody: t_reactionsCreateForPullRequestReviewCommentJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_reaction> | Res<201, t_reaction> | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/pulls/comments/${p["commentId"]}/reactions`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reactionsDeleteForPullRequestComment(
    p: {
      owner: string
      repo: string
      commentId: number
      reactionId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/pulls/comments/${p["commentId"]}/reactions/${p["reactionId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async pullsGet(
    p: {
      owner: string
      repo: string
      pullNumber: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_pull_request>
      | Res<304, void>
      | Res<404, t_basic_error>
      | Res<406, t_basic_error>
      | Res<500, t_basic_error>
      | Res<503, t_pullsGetJson503Response>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async pullsUpdate(
    p: {
      owner: string
      repo: string
      pullNumber: number
      requestBody?: t_pullsUpdateJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_pull_request>
      | Res<403, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PATCH", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async codespacesCreateWithPrForAuthenticatedUser(
    p: {
      owner: string
      repo: string
      pullNumber: number
      requestBody: t_codespacesCreateWithPrForAuthenticatedUserJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_codespace>
      | Res<202, t_codespace>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<503, t_codespacesCreateWithPrForAuthenticatedUserJson503Response>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/codespaces`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async pullsListReviewComments(
    p: {
      owner: string
      repo: string
      pullNumber: number
      sort?: "created" | "updated"
      direction?: "asc" | "desc"
      since?: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_pull_request_review_comment[]>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/comments`
    const query = this._query({
      sort: p["sort"],
      direction: p["direction"],
      since: p["since"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async pullsCreateReviewComment(
    p: {
      owner: string
      repo: string
      pullNumber: number
      requestBody: t_pullsCreateReviewCommentJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_pull_request_review_comment>
      | Res<403, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/comments`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async pullsCreateReplyForReviewComment(
    p: {
      owner: string
      repo: string
      pullNumber: number
      commentId: number
      requestBody: t_pullsCreateReplyForReviewCommentJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<201, t_pull_request_review_comment> | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/comments/${p["commentId"]}/replies`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async pullsListCommits(
    p: {
      owner: string
      repo: string
      pullNumber: number
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_commit[]>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/commits`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async pullsListFiles(
    p: {
      owner: string
      repo: string
      pullNumber: number
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_diff_entry[]>
      | Res<422, t_validation_error>
      | Res<500, t_basic_error>
      | Res<503, t_pullsListFilesJson503Response>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/files`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async pullsCheckIfMerged(
    p: {
      owner: string
      repo: string
      pullNumber: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void> | Res<404, void>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/merge`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async pullsMerge(
    p: {
      owner: string
      repo: string
      pullNumber: number
      requestBody?: t_pullsMergeJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_pull_request_merge_result>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<405, t_pullsMergeJson405Response>
      | Res<409, t_pullsMergeJson409Response>
      | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/merge`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async pullsListRequestedReviewers(
    p: {
      owner: string
      repo: string
      pullNumber: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_pull_request_review_request>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/requested_reviewers`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async pullsRequestReviewers(
    p: {
      owner: string
      repo: string
      pullNumber: number
      requestBody?: t_pullsRequestReviewersJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<201, t_pull_request_simple> | Res<403, t_basic_error> | Res<422, void>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/requested_reviewers`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async pullsRemoveRequestedReviewers(
    p: {
      owner: string
      repo: string
      pullNumber: number
      requestBody: t_pullsRemoveRequestedReviewersJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_pull_request_simple> | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/requested_reviewers`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "DELETE", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async pullsListReviews(
    p: {
      owner: string
      repo: string
      pullNumber: number
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_pull_request_review[]>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/reviews`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async pullsCreateReview(
    p: {
      owner: string
      repo: string
      pullNumber: number
      requestBody?: t_pullsCreateReviewJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_pull_request_review>
      | Res<403, t_basic_error>
      | Res<422, t_validation_error_simple>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/reviews`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async pullsGetReview(
    p: {
      owner: string
      repo: string
      pullNumber: number
      reviewId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_pull_request_review> | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/reviews/${p["reviewId"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async pullsUpdateReview(
    p: {
      owner: string
      repo: string
      pullNumber: number
      reviewId: number
      requestBody: t_pullsUpdateReviewJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_pull_request_review> | Res<422, t_validation_error_simple>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/reviews/${p["reviewId"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async pullsDeletePendingReview(
    p: {
      owner: string
      repo: string
      pullNumber: number
      reviewId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_pull_request_review>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error_simple>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/reviews/${p["reviewId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async pullsListCommentsForReview(
    p: {
      owner: string
      repo: string
      pullNumber: number
      reviewId: number
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_review_comment[]> | Res<404, t_basic_error>>
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/reviews/${p["reviewId"]}/comments`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async pullsDismissReview(
    p: {
      owner: string
      repo: string
      pullNumber: number
      reviewId: number
      requestBody: t_pullsDismissReviewJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_pull_request_review>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error_simple>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/reviews/${p["reviewId"]}/dismissals`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async pullsSubmitReview(
    p: {
      owner: string
      repo: string
      pullNumber: number
      reviewId: number
      requestBody: t_pullsSubmitReviewJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_pull_request_review>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error_simple>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/reviews/${p["reviewId"]}/events`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async pullsUpdateBranch(
    p: {
      owner: string
      repo: string
      pullNumber: number
      requestBody?: t_pullsUpdateBranchJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<202, t_pullsUpdateBranchJson202Response>
      | Res<403, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/pulls/${p["pullNumber"]}/update-branch`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reposGetReadme(
    p: {
      owner: string
      repo: string
      ref?: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_content_file>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/readme`
    const query = this._query({ref: p["ref"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposGetReadmeInDirectory(
    p: {
      owner: string
      repo: string
      dir: string
      ref?: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_content_file>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/readme/${p["dir"]}`
    const query = this._query({ref: p["ref"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposListReleases(
    p: {
      owner: string
      repo: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_release[]> | Res<404, t_basic_error>>
  > {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/releases`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposCreateRelease(
    p: {
      owner: string
      repo: string
      requestBody: t_reposCreateReleaseJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_release>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/releases`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reposGetReleaseAsset(
    p: {
      owner: string
      repo: string
      assetId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_release_asset> | Res<302, void> | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/releases/assets/${p["assetId"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposUpdateReleaseAsset(
    p: {
      owner: string
      repo: string
      assetId: number
      requestBody?: t_reposUpdateReleaseAssetJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_release_asset>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/releases/assets/${p["assetId"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PATCH", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reposDeleteReleaseAsset(
    p: {
      owner: string
      repo: string
      assetId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/releases/assets/${p["assetId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async reposGenerateReleaseNotes(
    p: {
      owner: string
      repo: string
      requestBody: t_reposGenerateReleaseNotesJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_release_notes_content> | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/releases/generate-notes`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reposGetLatestRelease(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_release>>> {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/releases/latest`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposGetReleaseByTag(
    p: {
      owner: string
      repo: string
      tag: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_release> | Res<404, t_basic_error>>
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/releases/tags/${p["tag"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposGetRelease(
    p: {
      owner: string
      repo: string
      releaseId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_release> | Res<401, void>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/releases/${p["releaseId"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposUpdateRelease(
    p: {
      owner: string
      repo: string
      releaseId: number
      requestBody?: t_reposUpdateReleaseJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_release> | Res<404, t_basic_error>>
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/releases/${p["releaseId"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PATCH", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reposDeleteRelease(
    p: {
      owner: string
      repo: string
      releaseId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/releases/${p["releaseId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async reposListReleaseAssets(
    p: {
      owner: string
      repo: string
      releaseId: number
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_release_asset[]>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/releases/${p["releaseId"]}/assets`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposUploadReleaseAsset(
    p: {
      owner: string
      repo: string
      releaseId: number
      name: string
      label?: string
      requestBody?: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<201, t_release_asset> | Res<422, void>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/releases/${p["releaseId"]}/assets`
    const headers = this._headers({
      "Content-Type": "application/octet-stream",
    })
    const query = this._query({name: p["name"], label: p["label"]})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url + query,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reactionsListForRelease(
    p: {
      owner: string
      repo: string
      releaseId: number
      content?: "+1" | "laugh" | "heart" | "hooray" | "rocket" | "eyes"
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_reaction[]> | Res<404, t_basic_error>>
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/releases/${p["releaseId"]}/reactions`
    const query = this._query({
      content: p["content"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reactionsCreateForRelease(
    p: {
      owner: string
      repo: string
      releaseId: number
      requestBody: t_reactionsCreateForReleaseJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_reaction> | Res<201, t_reaction> | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/releases/${p["releaseId"]}/reactions`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reactionsDeleteForRelease(
    p: {
      owner: string
      repo: string
      releaseId: number
      reactionId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/releases/${p["releaseId"]}/reactions/${p["reactionId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async reposGetBranchRules(
    p: {
      owner: string
      repo: string
      branch: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_repository_rule_detailed[]>>> {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/rules/branches/${p["branch"]}`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposGetRepoRulesets(
    p: {
      owner: string
      repo: string
      perPage?: number
      page?: number
      includesParents?: boolean
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_repository_ruleset[]>
      | Res<404, t_basic_error>
      | Res<500, t_basic_error>
    >
  > {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/rulesets`
    const query = this._query({
      per_page: p["perPage"],
      page: p["page"],
      includes_parents: p["includesParents"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposCreateRepoRuleset(
    p: {
      owner: string
      repo: string
      requestBody: t_reposCreateRepoRulesetJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_repository_ruleset>
      | Res<404, t_basic_error>
      | Res<500, t_basic_error>
    >
  > {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/rulesets`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reposGetRepoRuleSuites(
    p: {
      owner: string
      repo: string
      ref?: string
      timePeriod?: "hour" | "day" | "week" | "month"
      actorName?: string
      ruleSuiteResult?: "pass" | "fail" | "bypass" | "all"
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_rule_suites>
      | Res<404, t_basic_error>
      | Res<500, t_basic_error>
    >
  > {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/rulesets/rule-suites`
    const query = this._query({
      ref: p["ref"],
      time_period: p["timePeriod"],
      actor_name: p["actorName"],
      rule_suite_result: p["ruleSuiteResult"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposGetRepoRuleSuite(
    p: {
      owner: string
      repo: string
      ruleSuiteId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_rule_suite> | Res<404, t_basic_error> | Res<500, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/rulesets/rule-suites/${p["ruleSuiteId"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposGetRepoRuleset(
    p: {
      owner: string
      repo: string
      rulesetId: number
      includesParents?: boolean
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_repository_ruleset>
      | Res<404, t_basic_error>
      | Res<500, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/rulesets/${p["rulesetId"]}`
    const query = this._query({includes_parents: p["includesParents"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposUpdateRepoRuleset(
    p: {
      owner: string
      repo: string
      rulesetId: number
      requestBody?: t_reposUpdateRepoRulesetJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_repository_ruleset>
      | Res<404, t_basic_error>
      | Res<500, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/rulesets/${p["rulesetId"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reposDeleteRepoRuleset(
    p: {
      owner: string
      repo: string
      rulesetId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<204, void> | Res<404, t_basic_error> | Res<500, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/rulesets/${p["rulesetId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async secretScanningListAlertsForRepo(
    p: {
      owner: string
      repo: string
      state?: "open" | "resolved"
      secretType?: string
      resolution?: string
      sort?: "created" | "updated"
      direction?: "asc" | "desc"
      page?: number
      perPage?: number
      before?: string
      after?: string
      validity?: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_secret_scanning_alert[]>
      | Res<404, void>
      | Res<503, t_secretScanningListAlertsForRepoJson503Response>
    >
  > {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/secret-scanning/alerts`
    const query = this._query({
      state: p["state"],
      secret_type: p["secretType"],
      resolution: p["resolution"],
      sort: p["sort"],
      direction: p["direction"],
      page: p["page"],
      per_page: p["perPage"],
      before: p["before"],
      after: p["after"],
      validity: p["validity"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async secretScanningGetAlert(
    p: {
      owner: string
      repo: string
      alertNumber: t_alert_number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_secret_scanning_alert>
      | Res<304, void>
      | Res<404, void>
      | Res<503, t_secretScanningGetAlertJson503Response>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/secret-scanning/alerts/${p["alertNumber"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async secretScanningUpdateAlert(
    p: {
      owner: string
      repo: string
      alertNumber: t_alert_number
      requestBody: t_secretScanningUpdateAlertJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_secret_scanning_alert>
      | Res<400, void>
      | Res<404, void>
      | Res<422, void>
      | Res<503, t_secretScanningUpdateAlertJson503Response>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/secret-scanning/alerts/${p["alertNumber"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PATCH", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async secretScanningListLocationsForAlert(
    p: {
      owner: string
      repo: string
      alertNumber: t_alert_number
      page?: number
      perPage?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_secret_scanning_location[]>
      | Res<404, void>
      | Res<503, t_secretScanningListLocationsForAlertJson503Response>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/secret-scanning/alerts/${p["alertNumber"]}/locations`
    const query = this._query({page: p["page"], per_page: p["perPage"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async securityAdvisoriesListRepositoryAdvisories(
    p: {
      owner: string
      repo: string
      direction?: "asc" | "desc"
      sort?: "created" | "updated" | "published"
      before?: string
      after?: string
      perPage?: number
      state?: "triage" | "draft" | "published" | "closed"
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_repository_advisory[]>
      | Res<400, t_scim_error>
      | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/security-advisories`
    const query = this._query({
      direction: p["direction"],
      sort: p["sort"],
      before: p["before"],
      after: p["after"],
      per_page: p["perPage"],
      state: p["state"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async securityAdvisoriesCreateRepositoryAdvisory(
    p: {
      owner: string
      repo: string
      requestBody: t_repository_advisory_create
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_repository_advisory>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/security-advisories`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async securityAdvisoriesCreatePrivateVulnerabilityReport(
    p: {
      owner: string
      repo: string
      requestBody: t_private_vulnerability_report_create
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_repository_advisory>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/security-advisories/reports`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async securityAdvisoriesGetRepositoryAdvisory(
    p: {
      owner: string
      repo: string
      ghsaId: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_repository_advisory>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/security-advisories/${p["ghsaId"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async securityAdvisoriesUpdateRepositoryAdvisory(
    p: {
      owner: string
      repo: string
      ghsaId: string
      requestBody: t_repository_advisory_update
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_repository_advisory>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/security-advisories/${p["ghsaId"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PATCH", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async securityAdvisoriesCreateRepositoryAdvisoryCveRequest(
    p: {
      owner: string
      repo: string
      ghsaId: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          202,
          t_securityAdvisoriesCreateRepositoryAdvisoryCveRequestJson202Response
        >
      | Res<400, t_scim_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/security-advisories/${p["ghsaId"]}/cve`

    return this._fetch(url, {method: "POST", ...(opts ?? {})}, timeout)
  }

  async securityAdvisoriesCreateFork(
    p: {
      owner: string
      repo: string
      ghsaId: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<202, t_full_repository>
      | Res<400, t_scim_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/security-advisories/${p["ghsaId"]}/forks`

    return this._fetch(url, {method: "POST", ...(opts ?? {})}, timeout)
  }

  async activityListStargazersForRepo(
    p: {
      owner: string
      repo: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_activityListStargazersForRepoJson200Response>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/stargazers`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposGetCodeFrequencyStats(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_code_frequency_stat[]>
      | Res<202, t_reposGetCodeFrequencyStatsJson202Response>
      | Res<204, void>
      | Res<422, void>
    >
  > {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/stats/code_frequency`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposGetCommitActivityStats(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_commit_activity[]>
      | Res<202, t_reposGetCommitActivityStatsJson202Response>
      | Res<204, void>
    >
  > {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/stats/commit_activity`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposGetContributorsStats(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_contributor_activity[]>
      | Res<202, t_reposGetContributorsStatsJson202Response>
      | Res<204, void>
    >
  > {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/stats/contributors`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposGetParticipationStats(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_participation_stats> | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/stats/participation`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposGetPunchCardStats(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_code_frequency_stat[]> | Res<204, void>>
  > {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/stats/punch_card`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposCreateCommitStatus(
    p: {
      owner: string
      repo: string
      sha: string
      requestBody: t_reposCreateCommitStatusJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<201, t_status>>> {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/statuses/${p["sha"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async activityListWatchersForRepo(
    p: {
      owner: string
      repo: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_simple_user[]>>> {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/subscribers`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async activityGetRepoSubscription(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_repository_subscription>
      | Res<403, t_basic_error>
      | Res<404, void>
    >
  > {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/subscription`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async activitySetRepoSubscription(
    p: {
      owner: string
      repo: string
      requestBody?: t_activitySetRepoSubscriptionJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_repository_subscription>>> {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/subscription`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async activityDeleteRepoSubscription(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/subscription`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async reposListTags(
    p: {
      owner: string
      repo: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_tag[]>>> {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/tags`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposListTagProtection(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_tag_protection[]>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/tags/protection`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposCreateTagProtection(
    p: {
      owner: string
      repo: string
      requestBody: t_reposCreateTagProtectionJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_tag_protection>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/tags/protection`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reposDeleteTagProtection(
    p: {
      owner: string
      repo: string
      tagProtectionId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<204, void> | Res<403, t_basic_error> | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/tags/protection/${p["tagProtectionId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async reposDownloadTarballArchive(
    p: {
      owner: string
      repo: string
      ref: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<302, void>>> {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/tarball/${p["ref"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposListTeams(
    p: {
      owner: string
      repo: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_team[]> | Res<404, t_basic_error>>> {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/teams`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposGetAllTopics(
    p: {
      owner: string
      repo: string
      page?: number
      perPage?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_topic> | Res<404, t_basic_error>>> {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/topics`
    const query = this._query({page: p["page"], per_page: p["perPage"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposReplaceAllTopics(
    p: {
      owner: string
      repo: string
      requestBody: t_reposReplaceAllTopicsJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_topic>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error_simple>
    >
  > {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/topics`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reposGetClones(
    p: {
      owner: string
      repo: string
      per?: "day" | "week"
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_clone_traffic> | Res<403, t_basic_error>>
  > {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/traffic/clones`
    const query = this._query({per: p["per"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposGetTopPaths(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_content_traffic[]> | Res<403, t_basic_error>>
  > {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/traffic/popular/paths`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposGetTopReferrers(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_referrer_traffic[]> | Res<403, t_basic_error>>
  > {
    const url =
      this.basePath +
      `/repos/${p["owner"]}/${p["repo"]}/traffic/popular/referrers`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposGetViews(
    p: {
      owner: string
      repo: string
      per?: "day" | "week"
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_view_traffic> | Res<403, t_basic_error>>
  > {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/traffic/views`
    const query = this._query({per: p["per"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposTransfer(
    p: {
      owner: string
      repo: string
      requestBody: t_reposTransferJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<202, t_minimal_repository>>> {
    const url = this.basePath + `/repos/${p["owner"]}/${p["repo"]}/transfer`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reposCheckVulnerabilityAlerts(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void> | Res<404, void>>> {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/vulnerability-alerts`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposEnableVulnerabilityAlerts(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/vulnerability-alerts`

    return this._fetch(url, {method: "PUT", ...(opts ?? {})}, timeout)
  }

  async reposDisableVulnerabilityAlerts(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/vulnerability-alerts`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async reposDownloadZipballArchive(
    p: {
      owner: string
      repo: string
      ref: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<302, void>>> {
    const url =
      this.basePath + `/repos/${p["owner"]}/${p["repo"]}/zipball/${p["ref"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposCreateUsingTemplate(
    p: {
      templateOwner: string
      templateRepo: string
      requestBody: t_reposCreateUsingTemplateJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<201, t_full_repository>>> {
    const url =
      this.basePath +
      `/repos/${p["templateOwner"]}/${p["templateRepo"]}/generate`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reposListPublic(
    p: {
      since?: number
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_minimal_repository[]>
      | Res<304, void>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/repositories`
    const query = this._query({since: p["since"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async searchCode(
    p: {
      q: string
      sort?: "indexed"
      order?: "desc" | "asc"
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_searchCodeJson200Response>
      | Res<304, void>
      | Res<403, t_basic_error>
      | Res<422, t_validation_error>
      | Res<503, t_searchCodeJson503Response>
    >
  > {
    const url = this.basePath + `/search/code`
    const query = this._query({
      q: p["q"],
      sort: p["sort"],
      order: p["order"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async searchCommits(
    p: {
      q: string
      sort?: "author-date" | "committer-date"
      order?: "desc" | "asc"
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_searchCommitsJson200Response> | Res<304, void>
    >
  > {
    const url = this.basePath + `/search/commits`
    const query = this._query({
      q: p["q"],
      sort: p["sort"],
      order: p["order"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async searchIssuesAndPullRequests(
    p: {
      q: string
      sort?:
        | "comments"
        | "reactions"
        | "reactions-+1"
        | "reactions--1"
        | "reactions-smile"
        | "reactions-thinking_face"
        | "reactions-heart"
        | "reactions-tada"
        | "interactions"
        | "created"
        | "updated"
      order?: "desc" | "asc"
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_searchIssuesAndPullRequestsJson200Response>
      | Res<304, void>
      | Res<403, t_basic_error>
      | Res<422, t_validation_error>
      | Res<503, t_searchIssuesAndPullRequestsJson503Response>
    >
  > {
    const url = this.basePath + `/search/issues`
    const query = this._query({
      q: p["q"],
      sort: p["sort"],
      order: p["order"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async searchLabels(
    p: {
      repositoryId: number
      q: string
      sort?: "created" | "updated"
      order?: "desc" | "asc"
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_searchLabelsJson200Response>
      | Res<304, void>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/search/labels`
    const query = this._query({
      repository_id: p["repositoryId"],
      q: p["q"],
      sort: p["sort"],
      order: p["order"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async searchRepos(
    p: {
      q: string
      sort?: "stars" | "forks" | "help-wanted-issues" | "updated"
      order?: "desc" | "asc"
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_searchReposJson200Response>
      | Res<304, void>
      | Res<422, t_validation_error>
      | Res<503, t_searchReposJson503Response>
    >
  > {
    const url = this.basePath + `/search/repositories`
    const query = this._query({
      q: p["q"],
      sort: p["sort"],
      order: p["order"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async searchTopics(
    p: {
      q: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_searchTopicsJson200Response> | Res<304, void>>
  > {
    const url = this.basePath + `/search/topics`
    const query = this._query({
      q: p["q"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async searchUsers(
    p: {
      q: string
      sort?: "followers" | "repositories" | "joined"
      order?: "desc" | "asc"
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_searchUsersJson200Response>
      | Res<304, void>
      | Res<422, t_validation_error>
      | Res<503, t_searchUsersJson503Response>
    >
  > {
    const url = this.basePath + `/search/users`
    const query = this._query({
      q: p["q"],
      sort: p["sort"],
      order: p["order"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async teamsGetLegacy(
    p: {
      teamId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_team_full> | Res<404, t_basic_error>>
  > {
    const url = this.basePath + `/teams/${p["teamId"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async teamsUpdateLegacy(
    p: {
      teamId: number
      requestBody: t_teamsUpdateLegacyJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_team_full>
      | Res<201, t_team_full>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/teams/${p["teamId"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PATCH", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async teamsDeleteLegacy(
    p: {
      teamId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<204, void> | Res<404, t_basic_error> | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/teams/${p["teamId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async teamsListDiscussionsLegacy(
    p: {
      teamId: number
      direction?: "asc" | "desc"
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_team_discussion[]>>> {
    const url = this.basePath + `/teams/${p["teamId"]}/discussions`
    const query = this._query({
      direction: p["direction"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async teamsCreateDiscussionLegacy(
    p: {
      teamId: number
      requestBody: t_teamsCreateDiscussionLegacyJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<201, t_team_discussion>>> {
    const url = this.basePath + `/teams/${p["teamId"]}/discussions`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async teamsGetDiscussionLegacy(
    p: {
      teamId: number
      discussionNumber: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_team_discussion>>> {
    const url =
      this.basePath +
      `/teams/${p["teamId"]}/discussions/${p["discussionNumber"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async teamsUpdateDiscussionLegacy(
    p: {
      teamId: number
      discussionNumber: number
      requestBody?: t_teamsUpdateDiscussionLegacyJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_team_discussion>>> {
    const url =
      this.basePath +
      `/teams/${p["teamId"]}/discussions/${p["discussionNumber"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PATCH", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async teamsDeleteDiscussionLegacy(
    p: {
      teamId: number
      discussionNumber: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath +
      `/teams/${p["teamId"]}/discussions/${p["discussionNumber"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async teamsListDiscussionCommentsLegacy(
    p: {
      teamId: number
      discussionNumber: number
      direction?: "asc" | "desc"
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_team_discussion_comment[]>>> {
    const url =
      this.basePath +
      `/teams/${p["teamId"]}/discussions/${p["discussionNumber"]}/comments`
    const query = this._query({
      direction: p["direction"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async teamsCreateDiscussionCommentLegacy(
    p: {
      teamId: number
      discussionNumber: number
      requestBody: t_teamsCreateDiscussionCommentLegacyJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<201, t_team_discussion_comment>>> {
    const url =
      this.basePath +
      `/teams/${p["teamId"]}/discussions/${p["discussionNumber"]}/comments`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async teamsGetDiscussionCommentLegacy(
    p: {
      teamId: number
      discussionNumber: number
      commentNumber: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_team_discussion_comment>>> {
    const url =
      this.basePath +
      `/teams/${p["teamId"]}/discussions/${p["discussionNumber"]}/comments/${p["commentNumber"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async teamsUpdateDiscussionCommentLegacy(
    p: {
      teamId: number
      discussionNumber: number
      commentNumber: number
      requestBody: t_teamsUpdateDiscussionCommentLegacyJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_team_discussion_comment>>> {
    const url =
      this.basePath +
      `/teams/${p["teamId"]}/discussions/${p["discussionNumber"]}/comments/${p["commentNumber"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PATCH", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async teamsDeleteDiscussionCommentLegacy(
    p: {
      teamId: number
      discussionNumber: number
      commentNumber: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath +
      `/teams/${p["teamId"]}/discussions/${p["discussionNumber"]}/comments/${p["commentNumber"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async reactionsListForTeamDiscussionCommentLegacy(
    p: {
      teamId: number
      discussionNumber: number
      commentNumber: number
      content?:
        | "+1"
        | "-1"
        | "laugh"
        | "confused"
        | "heart"
        | "hooray"
        | "rocket"
        | "eyes"
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_reaction[]>>> {
    const url =
      this.basePath +
      `/teams/${p["teamId"]}/discussions/${p["discussionNumber"]}/comments/${p["commentNumber"]}/reactions`
    const query = this._query({
      content: p["content"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reactionsCreateForTeamDiscussionCommentLegacy(
    p: {
      teamId: number
      discussionNumber: number
      commentNumber: number
      requestBody: t_reactionsCreateForTeamDiscussionCommentLegacyJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<201, t_reaction>>> {
    const url =
      this.basePath +
      `/teams/${p["teamId"]}/discussions/${p["discussionNumber"]}/comments/${p["commentNumber"]}/reactions`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reactionsListForTeamDiscussionLegacy(
    p: {
      teamId: number
      discussionNumber: number
      content?:
        | "+1"
        | "-1"
        | "laugh"
        | "confused"
        | "heart"
        | "hooray"
        | "rocket"
        | "eyes"
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_reaction[]>>> {
    const url =
      this.basePath +
      `/teams/${p["teamId"]}/discussions/${p["discussionNumber"]}/reactions`
    const query = this._query({
      content: p["content"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reactionsCreateForTeamDiscussionLegacy(
    p: {
      teamId: number
      discussionNumber: number
      requestBody: t_reactionsCreateForTeamDiscussionLegacyJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<201, t_reaction>>> {
    const url =
      this.basePath +
      `/teams/${p["teamId"]}/discussions/${p["discussionNumber"]}/reactions`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async teamsListPendingInvitationsLegacy(
    p: {
      teamId: number
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_organization_invitation[]>>> {
    const url = this.basePath + `/teams/${p["teamId"]}/invitations`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async teamsListMembersLegacy(
    p: {
      teamId: number
      role?: "member" | "maintainer" | "all"
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_simple_user[]> | Res<404, t_basic_error>>
  > {
    const url = this.basePath + `/teams/${p["teamId"]}/members`
    const query = this._query({
      role: p["role"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async teamsGetMemberLegacy(
    p: {
      teamId: number
      username: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void> | Res<404, void>>> {
    const url = this.basePath + `/teams/${p["teamId"]}/members/${p["username"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async teamsAddMemberLegacy(
    p: {
      teamId: number
      username: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<204, void> | Res<403, t_basic_error> | Res<404, void> | Res<422, void>
    >
  > {
    const url = this.basePath + `/teams/${p["teamId"]}/members/${p["username"]}`

    return this._fetch(url, {method: "PUT", ...(opts ?? {})}, timeout)
  }

  async teamsRemoveMemberLegacy(
    p: {
      teamId: number
      username: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void> | Res<404, void>>> {
    const url = this.basePath + `/teams/${p["teamId"]}/members/${p["username"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async teamsGetMembershipForUserLegacy(
    p: {
      teamId: number
      username: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_team_membership> | Res<404, t_basic_error>>
  > {
    const url =
      this.basePath + `/teams/${p["teamId"]}/memberships/${p["username"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async teamsAddOrUpdateMembershipForUserLegacy(
    p: {
      teamId: number
      username: string
      requestBody?: t_teamsAddOrUpdateMembershipForUserLegacyJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_team_membership>
      | Res<403, void>
      | Res<404, t_basic_error>
      | Res<422, void>
    >
  > {
    const url =
      this.basePath + `/teams/${p["teamId"]}/memberships/${p["username"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async teamsRemoveMembershipForUserLegacy(
    p: {
      teamId: number
      username: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void> | Res<403, void>>> {
    const url =
      this.basePath + `/teams/${p["teamId"]}/memberships/${p["username"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async teamsListProjectsLegacy(
    p: {
      teamId: number
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_team_project[]> | Res<404, t_basic_error>>
  > {
    const url = this.basePath + `/teams/${p["teamId"]}/projects`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async teamsCheckPermissionsForProjectLegacy(
    p: {
      teamId: number
      projectId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_team_project> | Res<404, void>>> {
    const url =
      this.basePath + `/teams/${p["teamId"]}/projects/${p["projectId"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async teamsAddOrUpdateProjectPermissionsLegacy(
    p: {
      teamId: number
      projectId: number
      requestBody?: t_teamsAddOrUpdateProjectPermissionsLegacyJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<403, t_teamsAddOrUpdateProjectPermissionsLegacyJson403Response>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath + `/teams/${p["teamId"]}/projects/${p["projectId"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async teamsRemoveProjectLegacy(
    p: {
      teamId: number
      projectId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<204, void> | Res<404, t_basic_error> | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath + `/teams/${p["teamId"]}/projects/${p["projectId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async teamsListReposLegacy(
    p: {
      teamId: number
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_minimal_repository[]> | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/teams/${p["teamId"]}/repos`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async teamsCheckPermissionsForRepoLegacy(
    p: {
      teamId: number
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_team_repository> | Res<204, void> | Res<404, void>
    >
  > {
    const url =
      this.basePath + `/teams/${p["teamId"]}/repos/${p["owner"]}/${p["repo"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async teamsAddOrUpdateRepoPermissionsLegacy(
    p: {
      teamId: number
      owner: string
      repo: string
      requestBody?: t_teamsAddOrUpdateRepoPermissionsLegacyJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<204, void> | Res<403, t_basic_error> | Res<422, t_validation_error>
    >
  > {
    const url =
      this.basePath + `/teams/${p["teamId"]}/repos/${p["owner"]}/${p["repo"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async teamsRemoveRepoLegacy(
    p: {
      teamId: number
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url =
      this.basePath + `/teams/${p["teamId"]}/repos/${p["owner"]}/${p["repo"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async teamsListChildLegacy(
    p: {
      teamId: number
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_team[]>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/teams/${p["teamId"]}/teams`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async usersGetAuthenticated(
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_usersGetAuthenticatedJson200Response>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
    >
  > {
    const url = this.basePath + `/user`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async usersUpdateAuthenticated(
    p: {
      requestBody?: t_usersUpdateAuthenticatedJsonRequestBody
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_private_user>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/user`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PATCH", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async usersListBlockedByAuthenticatedUser(
    p: {
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_simple_user[]>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/user/blocks`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async usersCheckBlocked(
    p: {
      username: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/user/blocks/${p["username"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async usersBlock(
    p: {
      username: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/user/blocks/${p["username"]}`

    return this._fetch(url, {method: "PUT", ...(opts ?? {})}, timeout)
  }

  async usersUnblock(
    p: {
      username: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/user/blocks/${p["username"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async codespacesListForAuthenticatedUser(
    p: {
      perPage?: number
      page?: number
      repositoryId?: number
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_codespacesListForAuthenticatedUserJson200Response>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<500, t_basic_error>
    >
  > {
    const url = this.basePath + `/user/codespaces`
    const query = this._query({
      per_page: p["perPage"],
      page: p["page"],
      repository_id: p["repositoryId"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async codespacesCreateForAuthenticatedUser(
    p: {
      requestBody: t_codespacesCreateForAuthenticatedUserJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_codespace>
      | Res<202, t_codespace>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<503, t_codespacesCreateForAuthenticatedUserJson503Response>
    >
  > {
    const url = this.basePath + `/user/codespaces`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async codespacesListSecretsForAuthenticatedUser(
    p: {
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_codespacesListSecretsForAuthenticatedUserJson200Response>
    >
  > {
    const url = this.basePath + `/user/codespaces/secrets`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async codespacesGetPublicKeyForAuthenticatedUser(
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_codespaces_user_public_key>>> {
    const url = this.basePath + `/user/codespaces/secrets/public-key`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async codespacesGetSecretForAuthenticatedUser(
    p: {
      secretName: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_codespaces_secret>>> {
    const url = this.basePath + `/user/codespaces/secrets/${p["secretName"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async codespacesCreateOrUpdateSecretForAuthenticatedUser(
    p: {
      secretName: string
      requestBody: t_codespacesCreateOrUpdateSecretForAuthenticatedUserJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_empty_object>
      | Res<204, void>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/user/codespaces/secrets/${p["secretName"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async codespacesDeleteSecretForAuthenticatedUser(
    p: {
      secretName: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url = this.basePath + `/user/codespaces/secrets/${p["secretName"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async codespacesListRepositoriesForSecretForAuthenticatedUser(
    p: {
      secretName: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          t_codespacesListRepositoriesForSecretForAuthenticatedUserJson200Response
        >
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<500, t_basic_error>
    >
  > {
    const url =
      this.basePath + `/user/codespaces/secrets/${p["secretName"]}/repositories`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async codespacesSetRepositoriesForSecretForAuthenticatedUser(
    p: {
      secretName: string
      requestBody: t_codespacesSetRepositoriesForSecretForAuthenticatedUserJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<500, t_basic_error>
    >
  > {
    const url =
      this.basePath + `/user/codespaces/secrets/${p["secretName"]}/repositories`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async codespacesAddRepositoryForSecretForAuthenticatedUser(
    p: {
      secretName: string
      repositoryId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<500, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/user/codespaces/secrets/${p["secretName"]}/repositories/${p["repositoryId"]}`

    return this._fetch(url, {method: "PUT", ...(opts ?? {})}, timeout)
  }

  async codespacesRemoveRepositoryForSecretForAuthenticatedUser(
    p: {
      secretName: string
      repositoryId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<500, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/user/codespaces/secrets/${p["secretName"]}/repositories/${p["repositoryId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async codespacesGetForAuthenticatedUser(
    p: {
      codespaceName: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_codespace>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<500, t_basic_error>
    >
  > {
    const url = this.basePath + `/user/codespaces/${p["codespaceName"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async codespacesUpdateForAuthenticatedUser(
    p: {
      codespaceName: string
      requestBody?: t_codespacesUpdateForAuthenticatedUserJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_codespace>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/user/codespaces/${p["codespaceName"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PATCH", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async codespacesDeleteForAuthenticatedUser(
    p: {
      codespaceName: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<202, t_codespacesDeleteForAuthenticatedUserJson202Response>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<500, t_basic_error>
    >
  > {
    const url = this.basePath + `/user/codespaces/${p["codespaceName"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async codespacesExportForAuthenticatedUser(
    p: {
      codespaceName: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<202, t_codespace_export_details>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
      | Res<500, t_basic_error>
    >
  > {
    const url = this.basePath + `/user/codespaces/${p["codespaceName"]}/exports`

    return this._fetch(url, {method: "POST", ...(opts ?? {})}, timeout)
  }

  async codespacesGetExportDetailsForAuthenticatedUser(
    p: {
      codespaceName: string
      exportId: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_codespace_export_details> | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/user/codespaces/${p["codespaceName"]}/exports/${p["exportId"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async codespacesCodespaceMachinesForAuthenticatedUser(
    p: {
      codespaceName: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          t_codespacesCodespaceMachinesForAuthenticatedUserJson200Response
        >
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<500, t_basic_error>
    >
  > {
    const url =
      this.basePath + `/user/codespaces/${p["codespaceName"]}/machines`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async codespacesPublishForAuthenticatedUser(
    p: {
      codespaceName: string
      requestBody: t_codespacesPublishForAuthenticatedUserJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_codespace_with_full_repository>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/user/codespaces/${p["codespaceName"]}/publish`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async codespacesStartForAuthenticatedUser(
    p: {
      codespaceName: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_codespace>
      | Res<304, void>
      | Res<400, t_scim_error>
      | Res<401, t_basic_error>
      | Res<402, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<409, t_basic_error>
      | Res<500, t_basic_error>
    >
  > {
    const url = this.basePath + `/user/codespaces/${p["codespaceName"]}/start`

    return this._fetch(url, {method: "POST", ...(opts ?? {})}, timeout)
  }

  async codespacesStopForAuthenticatedUser(
    p: {
      codespaceName: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_codespace>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<500, t_basic_error>
    >
  > {
    const url = this.basePath + `/user/codespaces/${p["codespaceName"]}/stop`

    return this._fetch(url, {method: "POST", ...(opts ?? {})}, timeout)
  }

  async packagesListDockerMigrationConflictingPackagesForAuthenticatedUser(
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_package[]>>> {
    const url = this.basePath + `/user/docker/conflicts`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async usersSetPrimaryEmailVisibilityForAuthenticatedUser(
    p: {
      requestBody: t_usersSetPrimaryEmailVisibilityForAuthenticatedUserJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_email[]>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/user/email/visibility`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PATCH", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async usersListEmailsForAuthenticatedUser(
    p: {
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_email[]>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/user/emails`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async usersAddEmailForAuthenticatedUser(
    p: {
      requestBody?: t_usersAddEmailForAuthenticatedUserJsonRequestBody
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_email[]>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/user/emails`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async usersDeleteEmailForAuthenticatedUser(
    p: {
      requestBody: t_usersDeleteEmailForAuthenticatedUserJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/user/emails`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "DELETE", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async usersListFollowersForAuthenticatedUser(
    p: {
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_simple_user[]>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
    >
  > {
    const url = this.basePath + `/user/followers`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async usersListFollowedByAuthenticatedUser(
    p: {
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_simple_user[]>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
    >
  > {
    const url = this.basePath + `/user/following`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async usersCheckPersonIsFollowedByAuthenticated(
    p: {
      username: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/user/following/${p["username"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async usersFollow(
    p: {
      username: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/user/following/${p["username"]}`

    return this._fetch(url, {method: "PUT", ...(opts ?? {})}, timeout)
  }

  async usersUnfollow(
    p: {
      username: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/user/following/${p["username"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async usersListGpgKeysForAuthenticatedUser(
    p: {
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_gpg_key[]>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/user/gpg_keys`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async usersCreateGpgKeyForAuthenticatedUser(
    p: {
      requestBody: t_usersCreateGpgKeyForAuthenticatedUserJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_gpg_key>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/user/gpg_keys`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async usersGetGpgKeyForAuthenticatedUser(
    p: {
      gpgKeyId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_gpg_key>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/user/gpg_keys/${p["gpgKeyId"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async usersDeleteGpgKeyForAuthenticatedUser(
    p: {
      gpgKeyId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/user/gpg_keys/${p["gpgKeyId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async appsListInstallationsForAuthenticatedUser(
    p: {
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_appsListInstallationsForAuthenticatedUserJson200Response>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
    >
  > {
    const url = this.basePath + `/user/installations`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async appsListInstallationReposForAuthenticatedUser(
    p: {
      installationId: number
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_appsListInstallationReposForAuthenticatedUserJson200Response>
      | Res<304, void>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath + `/user/installations/${p["installationId"]}/repositories`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async appsAddRepoToInstallationForAuthenticatedUser(
    p: {
      installationId: number
      repositoryId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<304, void>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/user/installations/${p["installationId"]}/repositories/${p["repositoryId"]}`

    return this._fetch(url, {method: "PUT", ...(opts ?? {})}, timeout)
  }

  async appsRemoveRepoFromInstallationForAuthenticatedUser(
    p: {
      installationId: number
      repositoryId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<304, void>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, void>
    >
  > {
    const url =
      this.basePath +
      `/user/installations/${p["installationId"]}/repositories/${p["repositoryId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async interactionsGetRestrictionsForAuthenticatedUser(
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<
          200,
          t_interactionsGetRestrictionsForAuthenticatedUserJson200Response
        >
      | Res<204, void>
    >
  > {
    const url = this.basePath + `/user/interaction-limits`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async interactionsSetRestrictionsForAuthenticatedUser(
    p: {
      requestBody: t_interaction_limit
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_interaction_limit_response> | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/user/interaction-limits`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PUT", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async interactionsRemoveRestrictionsForAuthenticatedUser(
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void>>> {
    const url = this.basePath + `/user/interaction-limits`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async issuesListForAuthenticatedUser(
    p: {
      filter?:
        | "assigned"
        | "created"
        | "mentioned"
        | "subscribed"
        | "repos"
        | "all"
      state?: "open" | "closed" | "all"
      labels?: string
      sort?: "created" | "updated" | "comments"
      direction?: "asc" | "desc"
      since?: string
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_issue[]> | Res<304, void> | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/user/issues`
    const query = this._query({
      filter: p["filter"],
      state: p["state"],
      labels: p["labels"],
      sort: p["sort"],
      direction: p["direction"],
      since: p["since"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async usersListPublicSshKeysForAuthenticatedUser(
    p: {
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_key[]>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/user/keys`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async usersCreatePublicSshKeyForAuthenticatedUser(
    p: {
      requestBody: t_usersCreatePublicSshKeyForAuthenticatedUserJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_key>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/user/keys`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async usersGetPublicSshKeyForAuthenticatedUser(
    p: {
      keyId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_key>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/user/keys/${p["keyId"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async usersDeletePublicSshKeyForAuthenticatedUser(
    p: {
      keyId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/user/keys/${p["keyId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async appsListSubscriptionsForAuthenticatedUser(
    p: {
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_user_marketplace_purchase[]>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/user/marketplace_purchases`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async appsListSubscriptionsForAuthenticatedUserStubbed(
    p: {
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_user_marketplace_purchase[]>
      | Res<304, void>
      | Res<401, t_basic_error>
    >
  > {
    const url = this.basePath + `/user/marketplace_purchases/stubbed`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async orgsListMembershipsForAuthenticatedUser(
    p: {
      state?: "active" | "pending"
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_org_membership[]>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/user/memberships/orgs`
    const query = this._query({
      state: p["state"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async orgsGetMembershipForAuthenticatedUser(
    p: {
      org: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_org_membership>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/user/memberships/orgs/${p["org"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async orgsUpdateMembershipForAuthenticatedUser(
    p: {
      org: string
      requestBody: t_orgsUpdateMembershipForAuthenticatedUserJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_org_membership>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/user/memberships/orgs/${p["org"]}`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "PATCH", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async migrationsListForAuthenticatedUser(
    p: {
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_migration[]>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
    >
  > {
    const url = this.basePath + `/user/migrations`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async migrationsStartForAuthenticatedUser(
    p: {
      requestBody: t_migrationsStartForAuthenticatedUserJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_migration>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/user/migrations`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async migrationsGetStatusForAuthenticatedUser(
    p: {
      migrationId: number
      exclude?: string[]
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_migration>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/user/migrations/${p["migrationId"]}`
    const query = this._query({exclude: p["exclude"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async migrationsGetArchiveForAuthenticatedUser(
    p: {
      migrationId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<302, void>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
    >
  > {
    const url = this.basePath + `/user/migrations/${p["migrationId"]}/archive`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async migrationsDeleteArchiveForAuthenticatedUser(
    p: {
      migrationId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/user/migrations/${p["migrationId"]}/archive`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async migrationsUnlockRepoForAuthenticatedUser(
    p: {
      migrationId: number
      repoName: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/user/migrations/${p["migrationId"]}/repos/${p["repoName"]}/lock`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async migrationsListReposForAuthenticatedUser(
    p: {
      migrationId: number
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_minimal_repository[]> | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath + `/user/migrations/${p["migrationId"]}/repositories`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async orgsListForAuthenticatedUser(
    p: {
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_organization_simple[]>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
    >
  > {
    const url = this.basePath + `/user/orgs`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async packagesListPackagesForAuthenticatedUser(
    p: {
      packageType:
        | "npm"
        | "maven"
        | "rubygems"
        | "docker"
        | "nuget"
        | "container"
      visibility?: "public" | "private" | "internal"
      page?: number
      perPage?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_package[]> | Res<400, void>>> {
    const url = this.basePath + `/user/packages`
    const query = this._query({
      package_type: p["packageType"],
      visibility: p["visibility"],
      page: p["page"],
      per_page: p["perPage"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async packagesGetPackageForAuthenticatedUser(
    p: {
      packageType:
        | "npm"
        | "maven"
        | "rubygems"
        | "docker"
        | "nuget"
        | "container"
      packageName: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_package>>> {
    const url =
      this.basePath + `/user/packages/${p["packageType"]}/${p["packageName"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async packagesDeletePackageForAuthenticatedUser(
    p: {
      packageType:
        | "npm"
        | "maven"
        | "rubygems"
        | "docker"
        | "nuget"
        | "container"
      packageName: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath + `/user/packages/${p["packageType"]}/${p["packageName"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async packagesRestorePackageForAuthenticatedUser(
    p: {
      packageType:
        | "npm"
        | "maven"
        | "rubygems"
        | "docker"
        | "nuget"
        | "container"
      packageName: string
      token?: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/user/packages/${p["packageType"]}/${p["packageName"]}/restore`
    const query = this._query({token: p["token"]})

    return this._fetch(url + query, {method: "POST", ...(opts ?? {})}, timeout)
  }

  async packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser(
    p: {
      packageType:
        | "npm"
        | "maven"
        | "rubygems"
        | "docker"
        | "nuget"
        | "container"
      packageName: string
      page?: number
      perPage?: number
      state?: "active" | "deleted"
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_package_version[]>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/user/packages/${p["packageType"]}/${p["packageName"]}/versions`
    const query = this._query({
      page: p["page"],
      per_page: p["perPage"],
      state: p["state"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async packagesGetPackageVersionForAuthenticatedUser(
    p: {
      packageType:
        | "npm"
        | "maven"
        | "rubygems"
        | "docker"
        | "nuget"
        | "container"
      packageName: string
      packageVersionId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_package_version>>> {
    const url =
      this.basePath +
      `/user/packages/${p["packageType"]}/${p["packageName"]}/versions/${p["packageVersionId"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async packagesDeletePackageVersionForAuthenticatedUser(
    p: {
      packageType:
        | "npm"
        | "maven"
        | "rubygems"
        | "docker"
        | "nuget"
        | "container"
      packageName: string
      packageVersionId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/user/packages/${p["packageType"]}/${p["packageName"]}/versions/${p["packageVersionId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async packagesRestorePackageVersionForAuthenticatedUser(
    p: {
      packageType:
        | "npm"
        | "maven"
        | "rubygems"
        | "docker"
        | "nuget"
        | "container"
      packageName: string
      packageVersionId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/user/packages/${p["packageType"]}/${p["packageName"]}/versions/${p["packageVersionId"]}/restore`

    return this._fetch(url, {method: "POST", ...(opts ?? {})}, timeout)
  }

  async projectsCreateForAuthenticatedUser(
    p: {
      requestBody: t_projectsCreateForAuthenticatedUserJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_project>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<422, t_validation_error_simple>
    >
  > {
    const url = this.basePath + `/user/projects`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async usersListPublicEmailsForAuthenticatedUser(
    p: {
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_email[]>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/user/public_emails`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposListForAuthenticatedUser(
    p: {
      visibility?: "all" | "public" | "private"
      affiliation?: string
      type?: "all" | "owner" | "public" | "private" | "member"
      sort?: "created" | "updated" | "pushed" | "full_name"
      direction?: "asc" | "desc"
      perPage?: number
      page?: number
      since?: string
      before?: string
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_repository[]>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/user/repos`
    const query = this._query({
      visibility: p["visibility"],
      affiliation: p["affiliation"],
      type: p["type"],
      sort: p["sort"],
      direction: p["direction"],
      per_page: p["perPage"],
      page: p["page"],
      since: p["since"],
      before: p["before"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposCreateForAuthenticatedUser(
    p: {
      requestBody: t_reposCreateForAuthenticatedUserJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_full_repository>
      | Res<304, void>
      | Res<400, t_scim_error>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/user/repos`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async reposListInvitationsForAuthenticatedUser(
    p: {
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_repository_invitation[]>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/user/repository_invitations`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposAcceptInvitationForAuthenticatedUser(
    p: {
      invitationId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<304, void>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<409, t_basic_error>
    >
  > {
    const url =
      this.basePath + `/user/repository_invitations/${p["invitationId"]}`

    return this._fetch(url, {method: "PATCH", ...(opts ?? {})}, timeout)
  }

  async reposDeclineInvitationForAuthenticatedUser(
    p: {
      invitationId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<304, void>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<409, t_basic_error>
    >
  > {
    const url =
      this.basePath + `/user/repository_invitations/${p["invitationId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async usersListSocialAccountsForAuthenticatedUser(
    p: {
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_social_account[]>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/user/social_accounts`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async usersAddSocialAccountForAuthenticatedUser(
    p: {
      requestBody: t_usersAddSocialAccountForAuthenticatedUserJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_social_account[]>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/user/social_accounts`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async usersDeleteSocialAccountForAuthenticatedUser(
    p: {
      requestBody: t_usersDeleteSocialAccountForAuthenticatedUserJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/user/social_accounts`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "DELETE", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async usersListSshSigningKeysForAuthenticatedUser(
    p: {
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_ssh_signing_key[]>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/user/ssh_signing_keys`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async usersCreateSshSigningKeyForAuthenticatedUser(
    p: {
      requestBody: t_usersCreateSshSigningKeyForAuthenticatedUserJsonRequestBody
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<201, t_ssh_signing_key>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/user/ssh_signing_keys`
    const headers = this._headers({"Content-Type": "application/json"})
    const body = JSON.stringify(p.requestBody)

    return this._fetch(
      url,
      {method: "POST", headers, body, ...(opts ?? {})},
      timeout,
    )
  }

  async usersGetSshSigningKeyForAuthenticatedUser(
    p: {
      sshSigningKeyId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_ssh_signing_key>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/user/ssh_signing_keys/${p["sshSigningKeyId"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async usersDeleteSshSigningKeyForAuthenticatedUser(
    p: {
      sshSigningKeyId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/user/ssh_signing_keys/${p["sshSigningKeyId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async activityListReposStarredByAuthenticatedUser(
    p: {
      sort?: "created" | "updated"
      direction?: "asc" | "desc"
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_starred_repository[]>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
    >
  > {
    const url = this.basePath + `/user/starred`
    const query = this._query({
      sort: p["sort"],
      direction: p["direction"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async activityCheckRepoIsStarredByAuthenticatedUser(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/user/starred/${p["owner"]}/${p["repo"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async activityStarRepoForAuthenticatedUser(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/user/starred/${p["owner"]}/${p["repo"]}`

    return this._fetch(url, {method: "PUT", ...(opts ?? {})}, timeout)
  }

  async activityUnstarRepoForAuthenticatedUser(
    p: {
      owner: string
      repo: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/user/starred/${p["owner"]}/${p["repo"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async activityListWatchedReposForAuthenticatedUser(
    p: {
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_minimal_repository[]>
      | Res<304, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
    >
  > {
    const url = this.basePath + `/user/subscriptions`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async teamsListForAuthenticatedUser(
    p: {
      perPage?: number
      page?: number
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_team_full[]>
      | Res<304, void>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/user/teams`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async usersList(
    p: {
      since?: number
      perPage?: number
    } = {},
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_simple_user[]> | Res<304, void>>> {
    const url = this.basePath + `/users`
    const query = this._query({since: p["since"], per_page: p["perPage"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async usersGetByUsername(
    p: {
      username: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_usersGetByUsernameJson200Response> | Res<404, t_basic_error>
    >
  > {
    const url = this.basePath + `/users/${p["username"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async packagesListDockerMigrationConflictingPackagesForUser(
    p: {
      username: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_package[]> | Res<401, t_basic_error> | Res<403, t_basic_error>
    >
  > {
    const url = this.basePath + `/users/${p["username"]}/docker/conflicts`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async activityListEventsForAuthenticatedUser(
    p: {
      username: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_event[]>>> {
    const url = this.basePath + `/users/${p["username"]}/events`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async activityListOrgEventsForAuthenticatedUser(
    p: {
      username: string
      org: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_event[]>>> {
    const url =
      this.basePath + `/users/${p["username"]}/events/orgs/${p["org"]}`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async activityListPublicEventsForUser(
    p: {
      username: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_event[]>>> {
    const url = this.basePath + `/users/${p["username"]}/events/public`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async usersListFollowersForUser(
    p: {
      username: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_simple_user[]>>> {
    const url = this.basePath + `/users/${p["username"]}/followers`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async usersListFollowingForUser(
    p: {
      username: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_simple_user[]>>> {
    const url = this.basePath + `/users/${p["username"]}/following`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async usersCheckFollowingForUser(
    p: {
      username: string
      targetUser: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<204, void> | Res<404, void>>> {
    const url =
      this.basePath + `/users/${p["username"]}/following/${p["targetUser"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async gistsListForUser(
    p: {
      username: string
      since?: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_base_gist[]> | Res<422, t_validation_error>>
  > {
    const url = this.basePath + `/users/${p["username"]}/gists`
    const query = this._query({
      since: p["since"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async usersListGpgKeysForUser(
    p: {
      username: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_gpg_key[]>>> {
    const url = this.basePath + `/users/${p["username"]}/gpg_keys`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async usersGetContextForUser(
    p: {
      username: string
      subjectType?: "organization" | "repository" | "issue" | "pull_request"
      subjectId?: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_hovercard>
      | Res<404, t_basic_error>
      | Res<422, t_validation_error>
    >
  > {
    const url = this.basePath + `/users/${p["username"]}/hovercard`
    const query = this._query({
      subject_type: p["subjectType"],
      subject_id: p["subjectId"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async appsGetUserInstallation(
    p: {
      username: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_installation>>> {
    const url = this.basePath + `/users/${p["username"]}/installation`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async usersListPublicKeysForUser(
    p: {
      username: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_key_simple[]>>> {
    const url = this.basePath + `/users/${p["username"]}/keys`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async orgsListForUser(
    p: {
      username: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_organization_simple[]>>> {
    const url = this.basePath + `/users/${p["username"]}/orgs`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async packagesListPackagesForUser(
    p: {
      packageType:
        | "npm"
        | "maven"
        | "rubygems"
        | "docker"
        | "nuget"
        | "container"
      visibility?: "public" | "private" | "internal"
      username: string
      page?: number
      perPage?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_package[]>
      | Res<400, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
    >
  > {
    const url = this.basePath + `/users/${p["username"]}/packages`
    const query = this._query({
      package_type: p["packageType"],
      visibility: p["visibility"],
      page: p["page"],
      per_page: p["perPage"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async packagesGetPackageForUser(
    p: {
      packageType:
        | "npm"
        | "maven"
        | "rubygems"
        | "docker"
        | "nuget"
        | "container"
      packageName: string
      username: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_package>>> {
    const url =
      this.basePath +
      `/users/${p["username"]}/packages/${p["packageType"]}/${p["packageName"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async packagesDeletePackageForUser(
    p: {
      packageType:
        | "npm"
        | "maven"
        | "rubygems"
        | "docker"
        | "nuget"
        | "container"
      packageName: string
      username: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/users/${p["username"]}/packages/${p["packageType"]}/${p["packageName"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async packagesRestorePackageForUser(
    p: {
      packageType:
        | "npm"
        | "maven"
        | "rubygems"
        | "docker"
        | "nuget"
        | "container"
      packageName: string
      username: string
      token?: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/users/${p["username"]}/packages/${p["packageType"]}/${p["packageName"]}/restore`
    const query = this._query({token: p["token"]})

    return this._fetch(url + query, {method: "POST", ...(opts ?? {})}, timeout)
  }

  async packagesGetAllPackageVersionsForPackageOwnedByUser(
    p: {
      packageType:
        | "npm"
        | "maven"
        | "rubygems"
        | "docker"
        | "nuget"
        | "container"
      packageName: string
      username: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<200, t_package_version[]>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/users/${p["username"]}/packages/${p["packageType"]}/${p["packageName"]}/versions`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async packagesGetPackageVersionForUser(
    p: {
      packageType:
        | "npm"
        | "maven"
        | "rubygems"
        | "docker"
        | "nuget"
        | "container"
      packageName: string
      packageVersionId: number
      username: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_package_version>>> {
    const url =
      this.basePath +
      `/users/${p["username"]}/packages/${p["packageType"]}/${p["packageName"]}/versions/${p["packageVersionId"]}`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async packagesDeletePackageVersionForUser(
    p: {
      packageType:
        | "npm"
        | "maven"
        | "rubygems"
        | "docker"
        | "nuget"
        | "container"
      packageName: string
      username: string
      packageVersionId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/users/${p["username"]}/packages/${p["packageType"]}/${p["packageName"]}/versions/${p["packageVersionId"]}`

    return this._fetch(url, {method: "DELETE", ...(opts ?? {})}, timeout)
  }

  async packagesRestorePackageVersionForUser(
    p: {
      packageType:
        | "npm"
        | "maven"
        | "rubygems"
        | "docker"
        | "nuget"
        | "container"
      packageName: string
      username: string
      packageVersionId: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      | Res<204, void>
      | Res<401, t_basic_error>
      | Res<403, t_basic_error>
      | Res<404, t_basic_error>
    >
  > {
    const url =
      this.basePath +
      `/users/${p["username"]}/packages/${p["packageType"]}/${p["packageName"]}/versions/${p["packageVersionId"]}/restore`

    return this._fetch(url, {method: "POST", ...(opts ?? {})}, timeout)
  }

  async projectsListForUser(
    p: {
      username: string
      state?: "open" | "closed" | "all"
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<Res<200, t_project[]> | Res<422, t_validation_error>>
  > {
    const url = this.basePath + `/users/${p["username"]}/projects`
    const query = this._query({
      state: p["state"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async activityListReceivedEventsForUser(
    p: {
      username: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_event[]>>> {
    const url = this.basePath + `/users/${p["username"]}/received_events`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async activityListReceivedPublicEventsForUser(
    p: {
      username: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_event[]>>> {
    const url = this.basePath + `/users/${p["username"]}/received_events/public`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async reposListForUser(
    p: {
      username: string
      type?: "all" | "owner" | "member"
      sort?: "created" | "updated" | "pushed" | "full_name"
      direction?: "asc" | "desc"
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_minimal_repository[]>>> {
    const url = this.basePath + `/users/${p["username"]}/repos`
    const query = this._query({
      type: p["type"],
      sort: p["sort"],
      direction: p["direction"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async billingGetGithubActionsBillingUser(
    p: {
      username: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_actions_billing_usage>>> {
    const url =
      this.basePath + `/users/${p["username"]}/settings/billing/actions`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async billingGetGithubPackagesBillingUser(
    p: {
      username: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_packages_billing_usage>>> {
    const url =
      this.basePath + `/users/${p["username"]}/settings/billing/packages`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async billingGetSharedStorageBillingUser(
    p: {
      username: string
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_combined_billing_usage>>> {
    const url =
      this.basePath + `/users/${p["username"]}/settings/billing/shared-storage`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async usersListSocialAccountsForUser(
    p: {
      username: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_social_account[]>>> {
    const url = this.basePath + `/users/${p["username"]}/social_accounts`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async usersListSshSigningKeysForUser(
    p: {
      username: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_ssh_signing_key[]>>> {
    const url = this.basePath + `/users/${p["username"]}/ssh_signing_keys`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async activityListReposStarredByUser(
    p: {
      username: string
      sort?: "created" | "updated"
      direction?: "asc" | "desc"
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<
    TypedFetchResponse<
      Res<200, t_activityListReposStarredByUserJson200Response>
    >
  > {
    const url = this.basePath + `/users/${p["username"]}/starred`
    const query = this._query({
      sort: p["sort"],
      direction: p["direction"],
      per_page: p["perPage"],
      page: p["page"],
    })

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async activityListReposWatchedByUser(
    p: {
      username: string
      perPage?: number
      page?: number
    },
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, t_minimal_repository[]>>> {
    const url = this.basePath + `/users/${p["username"]}/subscriptions`
    const query = this._query({per_page: p["perPage"], page: p["page"]})

    return this._fetch(url + query, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async metaGetAllVersions(
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, string[]> | Res<404, t_basic_error>>> {
    const url = this.basePath + `/versions`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }

  async metaGetZen(
    timeout?: number,
    opts?: RequestInit,
  ): Promise<TypedFetchResponse<Res<200, string>>> {
    const url = this.basePath + `/zen`

    return this._fetch(url, {method: "GET", ...(opts ?? {})}, timeout)
  }
}
